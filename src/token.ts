import * as jose from 'jose';
import { MethodsPermissions } from './autogenerated/permissions';
import { PartialDeep } from 'type-fest';

const createPrivateKey = (key: string) => {
    const header = `-----BEGIN PRIVATE KEY-----\n`;
    const footer = `\n-----END PRIVATE KEY-----`;

    // @ts-ignore
    const keyBody = key.match(/.{1,64}/g).join('\n');
    return header + keyBody + footer;
};

const createToken = async (props: {
    appKeyId: string;
    appKeySecret: string;
    expiresInSeconds: number;
    payload: jose.JWTPayload;
}) => {
    const alg = 'RS256';
    const pkcs8 = createPrivateKey(props.appKeySecret);
    const privateKey = await jose.importPKCS8(pkcs8, alg);

    return await new jose.SignJWT(props.payload as any)
        .setIssuedAt()
        .setExpirationTime(`${props.expiresInSeconds}s`)
        .setProtectedHeader({ alg, kid: props.appKeyId })
        .sign(privateKey);
};

const serializePermissions = (permissions: PartialDeep<MethodsPermissions>): string[] => {
    const result: string[] = [];

    const traverse = (obj: any, path: string[] = []) => {
        for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'boolean' && value === true) {
                result.push(path.concat(key).join(':'));
            } else if (typeof value === 'object') {
                traverse(value, path.concat(key));
            }
        }
    };

    traverse(permissions);
    return result;
};

export const createTokenSigner = (options: { appId: string; appKeyId: string; appKeySecret: string }) => {
    if (!options.appId || options.appId.length === 0) {
        throw new Error('appId is required');
    }
    if (!options.appKeyId || options.appKeyId.length === 0) {
        throw new Error('appKeyId is required');
    }
    if (!options.appKeySecret || options.appKeySecret.length === 0) {
        throw new Error('appKeySecret is required');
    }

    return {
        createAccountToken: async (props: {
            accountId: string;
            expiresInSeconds: number;
            permissions?: PartialDeep<MethodsPermissions>;
            kind?: 'core-api' | 'directory-api';
        }) =>
            createToken({
                appKeyId: options.appKeyId,
                appKeySecret: options.appKeySecret,
                expiresInSeconds: props.expiresInSeconds,
                payload: {
                    iss: options.appId,
                    permissions: serializePermissions(props.permissions ?? {}),
                    sub: props.accountId,
                    kind: props.kind || 'core-api',
                },
            }),
        createRootToken: async (props: { expiresInSeconds: number; kind?: 'core-api' | 'directory-api' }) =>
            createToken({
                appKeyId: options.appKeyId,
                appKeySecret: options.appKeySecret,
                expiresInSeconds: props.expiresInSeconds ?? 3600,
                payload: {
                    iss: options.appId,
                    permissions: ['*'],
                    kind: props.kind || 'core-api',
                },
            }),
    };
};
