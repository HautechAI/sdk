import { wrapApiCallNullable, wrapCustomMethod } from '../../api-utils';
import { CoreApi } from '../../api-utils';
import {
    CreatePipelineParamsDto,
    CreatePipelineParamsDtoOutputRef,
    type CreatePipelineParamsDtoPipelineInput,
    OperationEntity,
    PipelineDto,
    PipelineDtoStatus,
    TaskDto,
} from '../../autogenerated/schemas';
import { SDK } from '../../types';
import { Methods, Pipeline } from '@hautechai/pipelines';
import {
    ChangeMethodSignaturesInObject,
    TaskOutput,
    WrapRef,
    WrapRefOrValue,
} from '@hautechai/pipelines/dist/pipeline';

const buildPipeline = <T extends SDK, O = any, I = any>(sdk: T & Methods): PipelineTyped<T, O, I> => {
    return new Pipeline(sdk) as unknown as PipelineTyped<T, O, I>;
};

export type PipelineTyped<TSdk extends SDK, O = any, I = any> = Omit<Pipeline<TSdk & Methods, O, I>, 'defer'> & {
    defer: Omit<ChangeMethodSignaturesInObject<TSdk & Methods>, 'operations'> & {
        operations: Omit<ChangeMethodSignaturesInObject<TSdk & Methods>['operations'], 'wait'> & {
            wait: <T extends WrapRefOrValue<OperationEntity>>(
                pipeline: WrapRefOrValue<T>,
                timeoutMs?: number,
            ) => TaskOutput<WrapRef<T>>;
        };
    };
};

export const usePipelinesApi = (hautechApi: CoreApi) => ({
    create: hautechApi.pipelinesControllerCreatePipelineV1,
    createFromTemplate: wrapCustomMethod(function <TSdk extends SDK, O = any, I = any>(
        this: any,
        template: PipelineTyped<TSdk, O, I>,
        params?: Partial<CreatePipelineParamsDto>,
    ) {
        const sdk: TSdk = this;

        return sdk.pipelines.create({
            pipelineInput: template.input as CreatePipelineParamsDtoPipelineInput,
            tasks: template.tasks as TaskDto[],
            outputRef: template.outputRef as CreatePipelineParamsDtoOutputRef,
            state: template.state,
            ...params,
        });
    }),
    get: wrapApiCallNullable(hautechApi.pipelinesControllerGetPipelineV1),
    list: hautechApi.pipelinesControllerListPipelinesV1,
    constructTemplate: wrapCustomMethod(function <TSdk extends SDK, O = any, I = any>(
        this: any,
        builder: (pipeline: PipelineTyped<TSdk>) => PipelineTyped<TSdk>,
    ): PipelineTyped<TSdk> {
        const sdk: TSdk = this;
        return builder(buildPipeline<TSdk, O, I>(sdk as TSdk & Methods));
    }),
    wait: wrapCustomMethod(async function <T extends PipelineDto>(
        this: any,
        pipeline: T,
        timeoutMs = 60000,
    ): Promise<T> {
        const sdk: SDK = this;

        const deadline = Date.now() + timeoutMs;
        const delay = 1000;

        const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

        const poll = async (id: string) => {
            const pipeline = await sdk.pipelines.get(id);

            if (!pipeline) {
                throw new Error('Pipeline not found');
            }

            if (pipeline.status !== PipelineDtoStatus.pending) return pipeline;

            return null;
        };

        while (Date.now() < deadline) {
            const polled = await poll(pipeline.id);
            if (polled) return polled as unknown as T;
            await sleep(delay);
        }

        throw new Error('Operation timed out');
    }),
});
