import { useApi, wrapApiCallNullable, wrapCustomMethod } from '../../api-utils';
import { getPipelines } from '../../autogenerated/pipelines/pipelines';
import {
    CreatePipelineParamsDto,
    CreatePipelineParamsDtoOutputRef,
    type CreatePipelineParamsDtoPipelineInput,
    OperationEntity,
    PipelineDto,
    PipelineDtoStatus,
    TaskDto,
} from '../../autogenerated/schemas';
import { PipelineSDK, SDK } from '../../types';
import { Methods, Pipeline } from '@hautechai/pipelines';
import {
    ChangeMethodSignaturesInObject,
    TaskOutput,
    UnwrapRef,
    WrapRef,
    WrapRefOrValue,
} from '@hautechai/pipelines/dist/pipeline';
import { usePipelineDefinitions } from '../../autogenerated/pipeline-methods';

const buildPipeline = <T extends PipelineSDK, O = any, I = any>(sdk: T & Methods): PipelineTyped<T, O, I> => {
    const pipelineDefinitions = usePipelineDefinitions();

    return new Pipeline(pipelineDefinitions) as unknown as PipelineTyped<T, O, I>;
};

export type PipelineTyped<TSdk extends PipelineSDK, O = any, I = any> = Omit<
    Pipeline<TSdk & Methods, O, I>,
    'defer'
> & {
    defer: Omit<ChangeMethodSignaturesInObject<TSdk & Methods>, 'operations'> & {
        operations: Omit<ChangeMethodSignaturesInObject<TSdk & Methods>['operations'], 'wait'> & {
            wait: <T extends WrapRefOrValue<OperationEntity>>(
                pipeline: WrapRefOrValue<T>,
                timeoutMs?: number,
            ) => TaskOutput<WrapRef<UnwrapRef<T>>>;
        };
    } & ChangeMethodSignaturesInObject<TSdk & Methods>;
};

export const usePipelinesApi = () => {
    const hautechApi = getPipelines();

    const api = {
        create: hautechApi.pipelinesControllerCreatePipelineV1,
        createFromTemplate: wrapCustomMethod(function <TSdk extends PipelineSDK, O = any, I = any>(
            this: any,
            template: PipelineTyped<TSdk, O, I>,
            params?: Partial<CreatePipelineParamsDto>,
        ) {
            const sdk: SDK = this;

            return sdk.pipelines.create({
                pipelineInput: template.input as CreatePipelineParamsDtoPipelineInput,
                tasks: template.tasks as TaskDto[],
                outputRef: template.outputRef as CreatePipelineParamsDtoOutputRef,
                state: template.state,
                ...params,
            });
        }),
        get: wrapApiCallNullable(hautechApi.pipelinesControllerGetPipelineV1),
        count: hautechApi.pipelinesControllerCountPipelinesV1,
        list: hautechApi.pipelinesControllerListPipelinesV1,
        constructTemplate: wrapCustomMethod(function <TSdk extends PipelineSDK, O = any, I = any>(
            this: any,
            builder: (pipeline: PipelineTyped<TSdk>) => PipelineTyped<TSdk>,
        ): PipelineTyped<TSdk> {
            const sdk: TSdk = this;
            return builder(buildPipeline<TSdk, O, I>(sdk as TSdk & Methods));
        }),
        wait: wrapCustomMethod(async function <T extends PipelineDto>(
            this: any,
            pipeline: T,
            timeoutMs = 60000,
            delay = 3000,
        ): Promise<T> {
            const sdk: SDK = this;

            const deadline = Date.now() + timeoutMs;

            const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

            const poll = async (id: string) => {
                const pipeline = await sdk.pipelines.get(id);

                if (!pipeline) {
                    throw new Error('Pipeline not found');
                }

                if (pipeline.status !== PipelineDtoStatus.pending) return pipeline;

                return null;
            };

            while (Date.now() < deadline) {
                const polled = await poll(pipeline.id);
                if (polled) return polled as unknown as T;
                await sleep(delay);
            }

            throw new Error('Operation timed out');
        }),
    };

    return useApi(api);
};
