import { wrapApiCallNullable, wrapCustomMethod } from '../../api';
import { CoreApi } from '../../api';
import { SDK } from '../../types';
import { OperationEntity } from '../../autogenerated/schemas';

export const useOperationsApi = (hautechApi: CoreApi) => ({
    run: {
        segmentAnything: {
            embeddings: {
                v1: hautechApi.operationsControllerRunSegmentAnythingEmbeddingsV1V1,
            },
        },
        poseEstimation: {
            v1: hautechApi.operationsControllerRunPoseEstimationV1V1,
        },
    },
    get: wrapApiCallNullable(hautechApi.operationsControllerGetOperationV1),
    wait: wrapCustomMethod(async function <T extends Omit<OperationEntity, 'output'>>(
        this: any,
        operation: T,
        timeoutMs = 60000,
    ): Promise<T> {
        const sdk: SDK = this;

        const deadline = Date.now() + timeoutMs;
        const delay = 1000;

        const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

        const poll = async (id: string) => {
            const operation = await sdk.operations.get(id);

            if (!operation) {
                throw new Error('Operation not found');
            }

            if (operation.status !== 'pending') return operation;

            return null;
        };

        while (Date.now() < deadline) {
            const polled = await poll(operation.id);
            if (polled) return polled as unknown as T;
            await sleep(delay);
        }

        throw new Error('Operation timed out');
    }),
});