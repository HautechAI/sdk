import { api, wrapApiCallNullable, wrapCustomMethod } from '../api';
import FormData from 'form-data';
import fs from 'fs';
import axios from 'axios';
import { SDK } from '../types';
import { OperationEntity } from '../autogenerated/schemas';

export const apiDefinitions = {
    videos: {
        get: api.videosControllerGetVideoByIdV1,
        list: api.videosControllerGetVideosV1,
        startUpload: api.videosControllerStartUploadV1,
        finalizeUpload: api.videosControllerFinalizeUploadV1,
        createFromFile: async function (
            this: any,
            file:
                | string
                | Blob
                | {
                      stream: NodeJS.ReadableStream;
                      filename: string;
                      contentType: string;
                  },
        ): Promise<string> {
            const sdk: SDK = this;
            const uploadResult = await sdk.videos.startUpload();

            const formData = new FormData();

            if (typeof file === 'string') {
                formData.append('file', fs.createReadStream(file));
            } else if ((global as any).Blob && file instanceof Blob) {
                formData.append('file', file);
            } else if (typeof file === 'object' && 'filename' in file) {
                formData.append('file', file.stream, {
                    filename: file.filename,
                    contentType: file.contentType,
                });
            } else {
                throw new Error('Unsupported file type');
            }

            const uploadResponse = await axios.put(uploadResult.uploadUrl, formData, {
                headers: {
                    ...formData.getHeaders(),
                },
                maxBodyLength: Infinity,
                timeout: 10000,
            });

            const fileToken = uploadResponse.data.fileToken;
            const finalizeResult = await sdk.videos.finalizeUpload({
                fileToken: fileToken,
            });

            if (!finalizeResult?.id) {
                throw new Error('Failed to finalize video upload');
            }

            return finalizeResult.id;
        },
        createFromUrl: async function (this: any, fileUrl: string): Promise<string> {
            const sdk: SDK = this;

            const isBrowser = typeof window !== 'undefined' && typeof Blob !== 'undefined';

            if (isBrowser) {
                const response = await axios.get(fileUrl, { responseType: 'blob' });
                const blob = new Blob([response.data], { type: response.headers['content-type'] });
                return sdk.videos.createFromFile(blob);
            } else {
                const response = await axios.get(fileUrl, { responseType: 'stream' });
                return sdk.videos.createFromFile({
                    stream: response.data,
                    filename: fileUrl.split('/').pop()!,
                    contentType: response.headers['content-type'] || 'application/octet-stream',
                });
            }
        },
    },
    workflows: {
        create: api.workflowsControllerCreateWorkflowV1,
        get: wrapApiCallNullable(api.workflowsControllerGetWorkflowV1),
        list: api.workflowsControllerListWorkflowsV1,
        update: api.workflowsControllerUpdateWorkflowV1,
    },
    storage: {
        create: api.storageControllerCreateRecordV1,
        getMany: api.storageControllerGetRecordsV1,
        delete: api.storageControllerDeleteRecordV1,
        update: api.storageControllerUpdateRecordV1,
    },
    stacks: {
        create: api.stacksControllerCreateStackV1,
        list: api.stacksControllerListStacksV1,
        get: wrapApiCallNullable(api.stacksControllerGetStackV1),
        updateMetadata: api.stacksControllerUpdateMetadataV1,
        items: {
            add: api.stacksControllerAddItemsV1,
            remove: api.stacksControllerRemoveItemsV1,
        },
    },
    poses: {
        get: wrapApiCallNullable(api.posesControllerGetPoseV1),
        list: api.posesControllerListPosesV1,
        setPreview: api.posesControllerSetPosePreviewV1,
        updateMetadata: api.posesControllerUpdateMetadataV1,
    },
    images: {
        startUpload: api.imagesControllerStartUploadV1,
        finalizeUpload: api.imagesControllerFinalizeUploadV1,
        get: wrapApiCallNullable(api.imagesControllerGetImageV1),
        getUrls: api.imagesControllerGetUrlsV1,
        getRepresentation: api.imagesControllerGetRepresentationV1,
        createFromFile: async function (
            this: any,
            file:
                | string
                | Blob
                | {
                      stream: NodeJS.ReadableStream;
                      filename: string;
                      contentType: string;
                  },
        ): Promise<string> {
            const sdk: SDK = this;
            const uploadResult = await sdk.images.startUpload();

            const formData = new FormData();

            if (typeof file === 'string') {
                formData.append('file', fs.createReadStream(file));
            } else if ((global as any).Blob && file instanceof Blob) {
                formData.append('file', file);
            } else if (typeof file === 'object' && 'filename' in file) {
                formData.append('file', file.stream, {
                    filename: file.filename,
                    contentType: file.contentType,
                });
            } else {
                throw new Error('Unsupported file type');
            }

            const uploadResponse = await axios.put(uploadResult.uploadUrl, formData, {
                headers: {
                    ...formData.getHeaders(),
                },
                maxBodyLength: Infinity,
                timeout: 10000,
            });

            const fileToken = uploadResponse.data.fileToken;
            const finalizeResult = await sdk.images.finalizeUpload({
                fileToken: fileToken,
            });

            if (!finalizeResult?.id) {
                throw new Error('Failed to finalize image upload');
            }

            return finalizeResult.id;
        },
        createFromUrl: async function (this: any, fileUrl: string): Promise<string> {
            const sdk: SDK = this;

            const isBrowser = typeof window !== 'undefined' && typeof Blob !== 'undefined';

            if (isBrowser) {
                const response = await axios.get(fileUrl, { responseType: 'blob' });
                const blob = new Blob([response.data], { type: response.headers['content-type'] });
                return sdk.images.createFromFile(blob);
            } else {
                const response = await axios.get(fileUrl, { responseType: 'stream' });
                return sdk.images.createFromFile({
                    stream: response.data,
                    filename: fileUrl.split('/').pop()!,
                    contentType: response.headers['content-type'] || 'application/octet-stream',
                });
            }
        },
    },
    operations: {
        run: {
            segmentAnything: {
                embeddings: {
                    v1: api.operationsControllerRunSegmentAnythingEmbeddingsV1V1,
                },
            },
            poseEstimation: {
                v1: api.operationsControllerRunPoseEstimationV1V1,
            },
        },
        get: wrapApiCallNullable(api.operationsControllerGetOperationV1),
        wait: wrapCustomMethod(async function <T extends Omit<OperationEntity, 'output'>>(
            this: any,
            operation: T,
            timeoutMs = 60000,
        ): Promise<T> {
            const sdk: SDK = this;

            const deadline = Date.now() + timeoutMs;
            const delay = 1000;

            const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

            const poll = async (id: string) => {
                const operation = await sdk.operations.get(id);

                if (!operation) {
                    throw new Error('Operation not found');
                }

                if (operation.status !== 'pending') return operation;

                return null;
            };

            while (Date.now() < deadline) {
                const polled = await poll(operation.id);
                if (polled) return polled as unknown as T;
                await sleep(delay);
            }

            throw new Error('Operation timed out');
        }),
    },
};
