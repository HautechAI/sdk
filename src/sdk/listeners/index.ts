import { OperationEntity, OperationsApi } from '../../autogenerated';
import { WebSocket } from 'ws';
import { HautechException } from '../exceptions';

// This is pretty much a dirty solution until we need to rework this part.
export class OperationsListener {
    useWebsocket: {
        endpoint: string;
        token: () => string | Promise<string>;
    } | null = null;
    ws: WebSocket | null = null;
    operations: () => Promise<OperationsApi>;

    constructor({
        ws,
        operations,
    }: {
        ws: {
            endpoint: string;
            token: () => string | Promise<string>;
        } | null;
        operations: () => Promise<OperationsApi>;
    }) {
        if (ws) {
            this.useWebsocket = {
                endpoint: ws?.endpoint,
                token: ws?.token,
            };
        }

        this.operations = operations;
    }

    operationsStore: Record<string, OperationEntity> = {};

    async getOperation(id: string): Promise<OperationEntity | null> {
        const isWsReady = this.ws?.readyState == WebSocket.OPEN;
        if (!this.operationsStore[id] || !isWsReady) {
            const api = await this.operations();
            const operation = await api.operationsControllerGetOperationV1(id);
            if (operation.status == 200) this.updateOperation(id, operation.data);
        }
        return this.operationsStore[id] || null;
    }

    private updateOperation(id: string, operation: OperationEntity) {
        const stored = this.operationsStore[id];
        if (!stored || stored.updatedAt < operation.updatedAt) {
            this.operationsStore[id] = operation;
        }
    }

    async subscribe() {
        if (!this.useWebsocket) return;
        try {
            this.ws = new WebSocket(this.useWebsocket.endpoint, ['1', await this.useWebsocket.token()]);
            this.ws.on('open', () => this.onOpen());
            this.ws.on('message', (msg: string) => this.onMessage(msg));
            this.ws.on('close', (number, reason) => this.onClose(number, reason));
        } catch (err) {
            throw new HautechException(`SDK failed to open websocket: ${err}`);
        }
    }

    onOpen() {
        if (!this.ws) throw new HautechException('Semantics error: this is a bug.');

        this.ws.send(
            JSON.stringify({
                event: 'subscribe',
                data: {
                    channel: 'own_resources',
                },
            }),
        );
    }

    onMessage(msg: string) {
        if (!this.ws) throw new HautechException('Semantics error: this is a bug.');

        const { event, data } = JSON.parse(msg) as any;
        switch (event) {
            case 'subscription:created':
                break;
            case 'operation:created':
            case 'operation:updated':
                this.updateOperation(data.id, data);
                break;
        }
    }

    onClose(number: number, reason: Buffer) {
        if (!this.ws) throw new HautechException('Semantics error: this is a bug.');
        // Reset dirty state.
        this.operationsStore = {};
        this.ws = null;
    }

    close() {
        if (!this.ws) return;
        this.ws.close();
    }
}
