import { OperationEntity, OperationsApi } from '../../autogenerated';
import { client as WebSocketClient, connection as Connection } from 'websocket';
import { HautechError } from '../errors';

// This is pretty much a dirty solution until we need to rework this part.
export class OperationsListener {
    useWebsocket: {
        endpoint: string;
        token: () => string | Promise<string>;
    } | null = null;
    ws: WebSocketClient | null = null;
    connection: Connection | null = null;
    operations: () => Promise<OperationsApi>;

    constructor({
        ws,
        operations,
    }: {
        ws: {
            endpoint: string;
            token: () => string | Promise<string>;
        } | null;
        operations: () => Promise<OperationsApi>;
    }) {
        if (ws) {
            this.useWebsocket = {
                endpoint: ws?.endpoint,
                token: ws?.token,
            };
        }

        this.operations = operations;
    }

    operationsStore: Record<string, OperationEntity> = {};

    async getOperation(id: string): Promise<OperationEntity | null> {
        const isWsReady = this.connection?.connected;
        if (!this.operationsStore[id] || !isWsReady) {
            const api = await this.operations();
            const operation = await api.operationsControllerGetOperationV1(id);
            if (operation.status == 200) this.updateOperation(id, operation.data);
        }
        return this.operationsStore[id] || null;
    }

    private updateOperation(id: string, operation: OperationEntity) {
        const stored = this.operationsStore[id];
        if (!stored || stored.updatedAt < operation.updatedAt) {
            this.operationsStore[id] = operation;
        }
    }

    async subscribe() {
        if (!this.useWebsocket) return;
        try {
            this.ws = new WebSocketClient();
            this.ws.connect(this.useWebsocket.endpoint, ['1', await this.useWebsocket.token()]);
            this.ws.on('connect', (connection) => {
                this.connection = connection;
                this.onOpen();

                connection.on('message', (msg) => {
                    if (msg.type === 'utf8') this.onMessage(msg.utf8Data);
                    else if (msg.type === 'binary') this.onMessage(msg.binaryData.toString('utf8'));
                });

                connection.on('close', (number, reason) => this.onClose(number, reason));
            });
        } catch (err) {
            throw new HautechError(`SDK failed to open websocket: ${err}`);
        }
    }

    onOpen() {
        if (!this.connection) throw new HautechError('Semantics error: this is a bug.');

        this.connection.send(
            JSON.stringify({
                event: 'subscribe',
                data: {
                    channel: 'own_resources',
                },
            }),
        );
    }

    onMessage(msg: string) {
        if (!this.connection) throw new HautechError('Semantics error: this is a bug.');

        const { event, data } = JSON.parse(msg) as any;
        switch (event) {
            case 'subscription:created':
                break;
            case 'operation:created':
            case 'operation:updated':
                this.updateOperation(data.id, data);
                break;
        }
    }

    onClose(number: number, reason: string) {
        if (!this.connection) throw new HautechError('Semantics error: this is a bug.');
        // Reset dirty state.
        this.operationsStore = {};
        this.ws = null;
    }

    close() {
        this.ws?.abort();
        this.connection?.close();
    }
}
