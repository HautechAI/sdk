import { wrapApiCallNullable, wrapCustomMethod } from '../../api';
import { CoreApi } from '../../api';
import { CreatePipelineParamsDto, PipelineDto, PipelineDtoStatus, TaskDto } from '../../autogenerated/schemas';
import { SDK } from '../../types';
import { Methods, Pipeline } from '@hautechai/pipelines';

const buildPipeline = <T extends SDK>(sdk: T & Methods): PipelineTyped<T> => {
    return new Pipeline(sdk) as PipelineTyped<T>;
};

type PipelineTyped<TSdk extends SDK> = Pipeline<TSdk & Methods>;

export const usePipelinesApi = (hautechApi: CoreApi) => ({
    create: hautechApi.pipelinesControllerCreatePipelineV1,
    createFromTemplate: wrapCustomMethod(function <TSdk extends SDK>(
        this: any,
        template: PipelineTyped<TSdk>,
        params?: Partial<CreatePipelineParamsDto>,
    ) {
        const sdk: TSdk = this;

        return sdk.pipelines.create({
            pipelineInput: template.input,
            tasks: template.tasks as TaskDto[],
            outputRef: template.outputRef,
            state: template.state,
            ...params,
        });
    }),
    get: wrapApiCallNullable(hautechApi.pipelinesControllerGetPipelineV1),
    list: hautechApi.pipelinesControllerListPipelinesV1,
    constructTemplate: wrapCustomMethod(function <TSdk extends SDK>(
        this: any,
        builder: (pipeline: PipelineTyped<TSdk>) => PipelineTyped<TSdk>,
    ): PipelineTyped<TSdk> {
        const sdk: TSdk = this;
        return builder(buildPipeline<TSdk>(sdk as TSdk & Methods));
    }),
    wait: wrapCustomMethod(async function <T extends PipelineDto>(
        this: any,
        pipeline: T,
        timeoutMs = 60000,
    ): Promise<T> {
        const sdk: SDK = this;

        const deadline = Date.now() + timeoutMs;
        const delay = 1000;

        const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

        const poll = async (id: string) => {
            const pipeline = await sdk.pipelines.get(id);

            if (!pipeline) {
                throw new Error('Pipeline not found');
            }

            if (pipeline.status !== PipelineDtoStatus.pending) return pipeline;

            return null;
        };

        while (Date.now() < deadline) {
            const polled = await poll(pipeline.id);
            if (polled) return polled as unknown as T;
            await sleep(delay);
        }

        throw new Error('Operation timed out');
    }),
});
