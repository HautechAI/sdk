import { AxiosResponse } from 'axios';
import {
    AnimateCreatomateV1Input,
    AnimateCreatomateV1Response,
    AnimateKling16ProV1Input,
    AnimateKling16ProV1Response,
    AnimateKling21V1Input,
    AnimateKling21V1Response,
    CompositeV1Input,
    CompositeV1Response,
    ContrastV1Input,
    ContrastV1Response,
    CropV1Input,
    CropV1Response,
    CutV1Input,
    CutV1Response,
    EditFluxKontextDevV1Input,
    EditFluxKontextDevV1Response,
    GiseleVtonV1Input,
    GPTV1Input,
    GptV1Response,
    GPTV2Input,
    GptV2Response,
    HauteLindaV1Response,
    HauteNaomiV1Response,
    ImagineKateV1Response,
    KateImagineV1Input,
    KateInpaintV1Input,
    LindaHauteV1Input,
    MathV1Input,
    MathV1Response,
    NaomiHauteV1Input,
    NegateImageV1Input,
    NegateImageV1Response,
    NoiseV1Input,
    NoiseV1Response,
    ObjectDetectionV1Input,
    ObjectDetectionV1Response,
    OperationEntity,
    OperationEntityStatusEnum,
    OperationsApi,
    PoseEstimationV1Input,
    PoseEstimationV1Response,
    ResizeV1Input,
    ResizeV1Response,
    SegmentAnythingEmbeddingsV1Input,
    SegmentAnythingEmbeddingsV1Response,
    SegmentAnythingMaskV1Input,
    SegmentAnythingMaskV1Response,
    StringsTemplateV1Input,
    StringsTemplateV1Response,
    TranslateV1Input,
    TranslateV1Response,
    UpscaleV1Input,
    UpscaleV1Response,
    VtonGiseleV1Response,
} from '../../autogenerated';
import { ListProps, ListResponse, SDKOptions } from '../../types';
import { useAutogeneratedAPI } from '../api';
import { OperationMetadata } from '../index';
import { OperationsListener } from '../listeners';
import { transformToListResponse } from '../transformers';
import { AddMetadata } from '../utils';

type OperationEntityWithMetadata = AddMetadata<OperationEntity, OperationMetadata>;
type Waited<T extends OperationEntityWithMetadata> = T &
    (
        | { status: typeof OperationEntityStatusEnum.Failed; output: null }
        | { status: typeof OperationEntityStatusEnum.Pending; output: null }
        | { status: typeof OperationEntityStatusEnum.Finished; output: NonNullable<T['output']> }
    );

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const operations = (options: SDKOptions, operationsListener: OperationsListener) => {
    const api = useAutogeneratedAPI({ API: OperationsApi, options });

    const createOperation =
        <T, R>(
            callMethod: (methods: OperationsApi, props: { input: T; metadata?: any }) => Promise<AxiosResponse<R, any>>,
        ) =>
        (props: { input: T; metadata?: any }) =>
            api.call({ run: (methods: OperationsApi) => callMethod(methods, props) });

    return {
        run: {
            animate: {
                kling_1_6_pro: {
                    v1: createOperation<AnimateKling16ProV1Input, AnimateKling16ProV1Response>((methods, props) =>
                        methods.operationsControllerRunAnimateKling16ProV1V1(props),
                    ),
                },
                kling_2_1: {
                    v1: createOperation<AnimateKling21V1Input, AnimateKling21V1Response>((methods, props) =>
                        methods.operationsControllerRunAnimateKling21V1V1(props),
                    ),
                },
                creatomate: {
                    v1: createOperation<AnimateCreatomateV1Input, AnimateCreatomateV1Response>((methods, props) =>
                        methods.operationsControllerRunAnimateCreatomateV1V1(props),
                    ),
                },
            },
            edit: {
                flux_kontext_dev: {
                    v1: createOperation<EditFluxKontextDevV1Input, EditFluxKontextDevV1Response>((methods, props) =>
                        methods.operationsControllerRunEditFluxKontextDevV1V1(props),
                    ),
                },
            },
            haute: {
                linda: {
                    v1: createOperation<LindaHauteV1Input, HauteLindaV1Response>((methods, props) =>
                        methods.operationsControllerRunHauteLindaV1V1(props),
                    ),
                },
                naomi: {
                    v1: createOperation<NaomiHauteV1Input, HauteNaomiV1Response>((methods, props) =>
                        methods.operationsControllerRunHauteNaomiV1V1(props),
                    ),
                },
            },
            inpaint: {
                kate: {
                    v1: createOperation<KateInpaintV1Input, ImagineKateV1Response>((methods, props) =>
                        methods.operationsControllerRunInpaintKateV1V1(props),
                    ),
                },
            },
            gpt: {
                v1: createOperation<GPTV1Input, GptV1Response>((methods, props) =>
                    methods.operationsControllerRunGptV1V1(props),
                ),
                v2: createOperation<GPTV2Input, GptV2Response>((methods, props) =>
                    methods.operationsControllerRunGptV2V1(props),
                ),
            },
            math: {
                v1: createOperation<MathV1Input, MathV1Response>((methods, props) =>
                    methods.operationsControllerRunMathV1V1(props),
                ),
            },
            translate: {
                v1: createOperation<TranslateV1Input, TranslateV1Response>((methods, props) =>
                    methods.operationsControllerRunTranslateV1V1(props),
                ),
            },
            imagine: {
                kate: {
                    v1: createOperation<KateImagineV1Input, ImagineKateV1Response>((methods, props) =>
                        methods.operationsControllerRunImagineKateV1V1(props),
                    ),
                },
            },
            upscale: {
                v1: createOperation<UpscaleV1Input, UpscaleV1Response>((methods, props) =>
                    methods.operationsControllerRunUpscaleV1V1(props),
                ),
            },
            objectDetection: {
                v1: createOperation<ObjectDetectionV1Input, ObjectDetectionV1Response>((methods, props) =>
                    methods.operationsControllerRunObjectDetectionV1V1(props),
                ),
            },
            segmentAnything: {
                embeddings: {
                    v1: createOperation<SegmentAnythingEmbeddingsV1Input, SegmentAnythingEmbeddingsV1Response>(
                        (methods, props) => methods.operationsControllerRunSegmentAnythingEmbeddingsV1V1(props),
                    ),
                },
                mask: {
                    v1: createOperation<SegmentAnythingMaskV1Input, SegmentAnythingMaskV1Response>((methods, props) =>
                        methods.operationsControllerRunSegmentAnythingMaskV1V1(props),
                    ),
                },
            },
            poseEstimation: {
                v1: createOperation<PoseEstimationV1Input, PoseEstimationV1Response>((methods, props) =>
                    methods.operationsControllerRunPoseEstimationV1V1(props),
                ),
            },
            cut: {
                v1: createOperation<CutV1Input, CutV1Response>((methods, props) =>
                    methods.operationsControllerRunCutV1V1(props),
                ),
            },
            crop: {
                v1: createOperation<CropV1Input, CropV1Response>((methods, props) =>
                    methods.operationsControllerRunCropV1V1(props),
                ),
            },
            noise: {
                v1: createOperation<NoiseV1Input, NoiseV1Response>((methods, props) =>
                    methods.operationsControllerRunNoiseV1V1(props),
                ),
            },
            contrast: {
                v1: createOperation<ContrastV1Input, ContrastV1Response>((methods, props) =>
                    methods.operationsControllerRunContrastV1V1(props),
                ),
            },
            composite: {
                v1: createOperation<CompositeV1Input, CompositeV1Response>((methods, props) =>
                    methods.operationsControllerRunCompositeV1V1(props),
                ),
            },
            vton: {
                gisele: {
                    v1: createOperation<GiseleVtonV1Input, VtonGiseleV1Response>((methods, props) =>
                        methods.operationsControllerRunVtonGiseleV1V1(props),
                    ),
                },
            },
            negateImage: {
                v1: createOperation<NegateImageV1Input, NegateImageV1Response>((methods, props) =>
                    methods.operationsControllerRunNegateImageV1V1(props),
                ),
            },
            resize: {
                v1: createOperation<ResizeV1Input, ResizeV1Response>((methods, props) =>
                    methods.operationsControllerRunResizeV1V1(props),
                ),
            },
            strings: {
                template: {
                    v1: createOperation<StringsTemplateV1Input, StringsTemplateV1Response>((methods, props) =>
                        methods.operationsControllerRunStringsTemplateV1V1(props),
                    ),
                },
            },
        },
        get: (props: { id: string }): Promise<OperationEntityWithMetadata | undefined> =>
            api.callWithReturningUndefinedOn404({
                run: (methods) => methods.operationsControllerGetOperationV1(props.id),
            }),
        getMany: (props: { ids: string[] }): Promise<OperationEntityWithMetadata[]> =>
            api.call({
                run: (methods) => methods.operationsControllerGetOperationsV1({ ids: props.ids }),
            }),
        list: (props: ListProps = {}): Promise<ListResponse<OperationEntityWithMetadata>> =>
            api.call({
                run: (methods) =>
                    methods.operationsControllerListOperationsV1(props.orderBy, props.limit, props.cursor),
                transform: transformToListResponse,
            }) as Promise<ListResponse<OperationEntityWithMetadata>>,
        updateMetadata: async (props: { id: string; metadata?: any }): Promise<void> =>
            api.call({
                run: (methods) => methods.operationsControllerUpdateMetadataV1(props.id, { overwrite: props.metadata }),
            }),
        wait: async <T extends OperationEntityWithMetadata | { id: string }, N extends number | undefined = undefined>(
            props: T,
            timeoutMs?: N,
        ): Promise<
            | Waited<T extends OperationEntityWithMetadata ? T : OperationEntityWithMetadata>
            | (N extends undefined ? never : null)
        > => {
            type RT = T extends OperationEntityWithMetadata ? T : OperationEntityWithMetadata;
            const deadline: number | undefined = timeoutMs ? Date.now() + timeoutMs : undefined;
            const delay = operationsListener.websocketEnabled() ? 50 : 1000;

            const poll = async (id: string): Promise<Waited<RT> | null> => {
                const operation = await operationsListener.getOperation(id);
                if (operation?.status !== 'pending') return operation as Waited<RT>;
                return null;
            };

            while (!deadline || Date.now() < deadline) {
                const polled = await poll(props.id);
                if (polled) return polled;
                await sleep(delay);
            }

            //@ts-expect-error - can't be reached if timeoutMs is defined.
            return null;
        },
    };
};

export default operations;
