import { AxiosResponse } from 'axios';
import {
    CompositeV1Input, CompositeV1Response,
    CutV1Input, CutV1Response,
    GiseleVtonV1Input,
    GPTV1Input, GptV1Response, HauteLindaV1Response, HauteNaomiV1Response, ImagineKateV1Response,
    KateImagineV1Input,
    KateInpaintV1Input,
    LindaHauteV1Input,
    NaomiHauteV1Input,
    ObjectDetectionV1Input, ObjectDetectionV1Response,
    OperationEntity,
    OperationsApi,
    PoseEstimationV1Input, PoseEstimationV1Response,
    SegmentAnythingEmbeddingsV1Input, SegmentAnythingEmbeddingsV1Response,
    SegmentAnythingMaskV1Input, SegmentAnythingMaskV1Response,
    UpscaleV1Input, UpscaleV1Response, VtonGiseleV1Response,
} from '../../autogenerated';
import { ListProps, ListResponse, SDKOptions } from '../../types';
import { useAutogeneratedAPI } from '../api';
import { transformToListResponse } from '../transformers';

const operations = (options: SDKOptions) => {
    const api = useAutogeneratedAPI({ API: OperationsApi, options });

    const createOperation =
        <T, R>(
            callMethod: (
                methods: OperationsApi,
                props: { input: T; metadata?: any },
            ) => Promise<AxiosResponse<R, any>>,
        ) =>
        (props: { input: T; metadata?: any }) =>
            api.call({ run: (methods: OperationsApi) => callMethod(methods, props) });

    return {
        create: {
            composite: {
                v1: createOperation<CompositeV1Input, CompositeV1Response>((methods, props) =>
                    methods.operationsControllerRunCompositeV1V1(props),
                ),
            },
            cut: {
                v1: createOperation<CutV1Input, CutV1Response>((methods, props) => methods.operationsControllerRunCutV1V1(props)),
            },
            detect: {
                v1: createOperation<ObjectDetectionV1Input, ObjectDetectionV1Response>((methods, props) =>
                    methods.operationsControllerRunObjectDetectionV1V1(props),
                ),
            },
            estimatePose: {
                v1: createOperation<PoseEstimationV1Input, PoseEstimationV1Response>((methods, props) =>
                    methods.operationsControllerRunPoseEstimationV1V1(props),
                ),
            },
            haute: {
                linda: {
                    v1: createOperation<LindaHauteV1Input, HauteLindaV1Response>((methods, props) =>
                        methods.operationsControllerRunHauteLindaV1V1(props),
                    ),
                },
                naomi: {
                    v1: createOperation<NaomiHauteV1Input, HauteNaomiV1Response>((methods, props) =>
                        methods.operationsControllerRunHauteNaomiV1V1(props),
                    ),
                },
            },
            gpt: {
                v1: createOperation<GPTV1Input, GptV1Response>((methods, props) => methods.operationsControllerRunGptV1V1(props)),
            },
            imagine: {
                kate: {
                    v1: createOperation<KateImagineV1Input, ImagineKateV1Response>((methods, props) =>
                        methods.operationsControllerRunImagineKateV1V1(props),
                    ),
                },
            },
            inpaint: {
                kate: {
                    v1: createOperation<KateInpaintV1Input, ImagineKateV1Response>((methods, props) =>
                        methods.operationsControllerRunInpaintKateV1V1(props),
                    ),
                },
            },
            segmentEmbeddings: {
                v1: createOperation<SegmentAnythingEmbeddingsV1Input, SegmentAnythingEmbeddingsV1Response>((methods, props) =>
                    methods.operationsControllerRunSegmentAnythingEmbeddingsV1V1(props),
                ),
            },
            segmentMask: {
                v1: createOperation<SegmentAnythingMaskV1Input, SegmentAnythingMaskV1Response>((methods, props) =>
                    methods.operationsControllerRunSegmentAnythingMaskV1V1(props),
                ),
            },
            upscale: {
                v1: createOperation<UpscaleV1Input, UpscaleV1Response>((methods, props) =>
                    methods.operationsControllerRunUpscaleV1V1(props),
                ),
            },
            vton: {
                gisele: {
                    v1: createOperation<GiseleVtonV1Input, VtonGiseleV1Response>((methods, props) =>
                        methods.operationsControllerRunVtonGiseleV1V1(props),
                    ),
                },
            },
        },
        get: (props: { id: string }): Promise<OperationEntity | undefined> =>
            api.callWithReturningUndefinedOn404({
                run: (methods) => methods.operationsControllerGetOperationV1(props.id),
            }),
        getMany: (props: { ids: string[] }): Promise<OperationEntity[]> =>
            api.call({
                run: (methods) => methods.operationsControllerGetOperationsV1({ ids: props.ids }),
            }),
        list: (props: ListProps = {}): Promise<ListResponse<OperationEntity>> =>
            api.call({
                run: (methods) =>
                    methods.operationsControllerListOperationsV1(props.orderBy, props.limit, props.cursor),
                transform: transformToListResponse,
            }),
        updateMetadata: async (props: { id: string; metadata?: any }): Promise<void> =>
            api.call({
                run: (methods) => methods.operationsControllerUpdateMetadataV1(props.id, { overwrite: props.metadata }),
            }),
        wait: async <T extends OperationEntity | { id: string }>(props: T): Promise<T extends OperationEntity ? T : OperationEntity> =>
            new Promise((resolve, reject) => {
                const initialDelay = 5000;
                const delay = 2000;

                let timeoutId: NodeJS.Timeout;
                const poll = async () => {
                    const operation = await api.call({
                        run: (methods) => methods.operationsControllerGetOperationV1(props.id),
                    });
                    if (operation.status !== 'pending') return resolve(operation as any);
                    timeoutId = setTimeout(poll, delay);
                };
                timeoutId = setTimeout(poll, initialDelay);
            }),
    };
};

export default operations;
