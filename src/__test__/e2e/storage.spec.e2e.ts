import { beforeAll, describe, expect, it } from 'vitest';
import { createTestSdk } from '../test-utils';
import type { CreateStorageRecordParamsDtoValue } from '../../autogenerated/schemas';

describe('Storage API E2E Tests', () => {
    let sdk = createTestSdk();
    let testKey: string;
    let testValue: CreateStorageRecordParamsDtoValue;

    beforeAll(async () => {
        testKey = `test-key-${Date.now()}`;
        testValue = {
            message: 'Hello from storage e2e test',
            timestamp: new Date().toISOString(),
            data: { nested: true, count: 42 },
        };

        await sdk.storage.create({ key: testKey, value: testValue });
    });

    describe('Storage CRUD Operations', () => {
        it('should create a new storage record', async () => {
            const createKey = `create-test-${Date.now()}`;
            const createValue = { test: 'create operation', number: 123 };

            const result = await sdk.storage.create({ key: createKey, value: createValue });
            expect(result).toBeDefined();
            expect(result.key).toBe(createKey);
            expect(result.value).toEqual(createValue);
            expect(result.createdAt).toBeDefined();
            expect(result.updatedAt).toBeDefined();
        });

        it('should get multiple storage records', async () => {
            const result = await sdk.storage.getMany({ keys: [testKey] });
            expect(result).toBeDefined();
            expect(result.length).toEqual(1);
            expect(result[0].key).toEqual(testKey);
        });

        it('should update an existing storage record', async () => {
            const updatedValue = {
                message: 'Updated message from storage e2e test',
                timestamp: new Date().toISOString(),
                data: { nested: true, count: 100, updated: true },
            };

            const result = await sdk.storage.update({ key: testKey, value: updatedValue });
            expect(result).toBeDefined();
            expect(result.key).toBe(testKey);
            expect(result.value).toEqual(updatedValue);
            expect(result.updatedAt).toBeDefined();

            const getResult = await sdk.storage.getMany({ keys: [testKey] });
            expect(getResult[0].key).toEqual(testKey);
            expect(getResult[0].value).toEqual(updatedValue);
        });

        it('should delete a storage record', async () => {
            const deleteKey = `delete-test-${Date.now()}`;
            const deleteValue = { test: 'delete operation' };

            await sdk.storage.create({ key: deleteKey, value: deleteValue });

            await sdk.storage.delete({ key: deleteKey });

            const getResult = await sdk.storage.getMany({ keys: [deleteKey] });
            expect(getResult[0]).toBeUndefined();
        });
    });

    describe('Storage Batch Operations', () => {
        it('should get multiple records at once', async () => {
            const key1 = `batch-test-1-${Date.now()}`;
            const key2 = `batch-test-2-${Date.now()}`;
            const value1 = { batch: 1, data: 'first' };
            const value2 = { batch: 2, data: 'second' };

            await sdk.storage.create({ key: key1, value: value1 });
            await sdk.storage.create({ key: key2, value: value2 });

            const result = await sdk.storage.getMany({ keys: [key1, key2] });
            expect(result).toBeDefined();
            expect(result.length).toEqual(2);
            expect(result[0].key).toEqual(key1);
            expect(result[1].key).toEqual(key2);
        });
    });

    describe('Storage getManyMap Operations', () => {
        it('should get multiple records as a map', async () => {
            const key1 = `map-test-1-${Date.now()}`;
            const key2 = `map-test-2-${Date.now()}`;
            const value1 = { map: 1, data: 'first' };
            const value2 = { map: 2, data: 'second' };

            await sdk.storage.create({ key: key1, value: value1 });
            await sdk.storage.create({ key: key2, value: value2 });

            const result = await sdk.storage.getManyMap({ keys: [key1, key2] });
            expect(result).toBeDefined();
            expect(typeof result).toBe('object');
            expect(result[key1]).toEqual(value1);
            expect(result[key2]).toEqual(value2);
            expect(Object.keys(result)).toHaveLength(2);
        });

        it('should get single record as a map', async () => {
            const key = `single-map-test-${Date.now()}`;
            const value = { single: true, message: 'test' };

            await sdk.storage.create({ key, value });

            const result = await sdk.storage.getManyMap({ keys: [key] });
            expect(result).toBeDefined();
            expect(typeof result).toBe('object');
            expect(result[key]).toEqual(value);
            expect(Object.keys(result)).toHaveLength(1);
        });

        it('should return empty map for non-existent keys', async () => {
            const nonExistentKey1 = `non-existent-map-1-${Date.now()}`;
            const nonExistentKey2 = `non-existent-map-2-${Date.now()}`;

            const result = await sdk.storage.getManyMap({ keys: [nonExistentKey1, nonExistentKey2] });
            expect(result).toBeDefined();
            expect(typeof result).toBe('object');
            expect(Object.keys(result)).toHaveLength(0);
        });

        it('should handle mixed existing and non-existent keys', async () => {
            const existingKey = `existing-map-test-${Date.now()}`;
            const nonExistentKey = `non-existent-map-test-${Date.now()}`;
            const value = { mixed: true, test: 'data' };

            await sdk.storage.create({ key: existingKey, value });

            const result = await sdk.storage.getManyMap({ keys: [existingKey, nonExistentKey] });
            expect(result).toBeDefined();
            expect(typeof result).toBe('object');
            expect(result[existingKey]).toEqual(value);
            expect(result[nonExistentKey]).toBeUndefined();
            expect(Object.keys(result)).toHaveLength(1);
        });

        it('should handle empty keys array', async () => {
            try {
                await sdk.storage.getManyMap({ keys: [] });
                expect(true).toBe(false); // Should not reach here
            } catch (error) {
                expect(error).toBeDefined();
            }
        });

        it('should handle complex nested values in map', async () => {
            const key = `complex-map-test-${Date.now()}`;
            const value = {
                nested: {
                    deep: {
                        level: 'test',
                        array: [1, 2, 3],
                        boolean: true,
                        null: null,
                    },
                },
                timestamp: new Date().toISOString(),
            };

            await sdk.storage.create({ key, value });

            const result = await sdk.storage.getManyMap({ keys: [key] });
            expect(result).toBeDefined();
            expect(result[key]).toEqual(value);

            const res = result[key] as typeof value;
            expect(res!.nested.deep.level).toBe('test');
            expect(res!.nested.deep.array).toEqual([1, 2, 3]);
        });
    });

    describe('Error Handling', () => {
        it('should handle invalid key gracefully', async () => {
            try {
                await sdk.storage.getMany({ keys: [null as any] });
                expect(true).toBe(false);
            } catch (error) {
                expect(error).toBeDefined();
            }
        });

        it('should handle non-existent key gracefully', async () => {
            const nonExistentKey = `non-existent-${Date.now()}`;
            const result = await sdk.storage.getMany({ keys: [nonExistentKey] });
            expect(result).toBeDefined();
            expect(result[0]).toBeUndefined();
        });

        it('should handle invalid create parameters gracefully', async () => {
            try {
                await sdk.storage.create({ key: '', value: null });
                expect(true).toBe(false);
            } catch (error) {
                expect(error).toBeDefined();
            }
        });

        it('should handle delete of non-existent key gracefully', async () => {
            const nonExistentKey = `non-existent-delete-${Date.now()}`;

            try {
                await sdk.storage.delete({ key: nonExistentKey });
            } catch (error) {
                expect(error).toBeDefined();
            }
        });
    });
});
