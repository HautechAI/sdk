import { describe, expect, it, beforeAll } from 'vitest';
import { createTestSdk } from '../test-utils';
import { LoraDtoModelType, LoraDtoStatus, PipelineDtoStatus } from '../../autogenerated/schemas';
import path from 'path';
import { v4 } from 'uuid';

describe('LoRAs E2E Tests', () => {
    const sdk = createTestSdk();
    let createdLoraId: string | null = null;

    // Create a real Naomi LoRA first so that subsequent tests can rely on it
    beforeAll(async () => {
        // Upload garment image for dataset
        const garmentImagePath = path.join(__dirname, 'assets', 'garment.png');
        const garmentImage = await sdk.images.createFromFile(garmentImagePath);

        // Upload output image for dataset
        const outputImagePath = path.join(__dirname, 'assets', 'pose.png');
        const outputImage = await sdk.images.createFromFile(outputImagePath);

        // Create training pipeline
        const pipelineData = sdk.pipelines.constructTemplate((pipeline) => {
            const prepareDatasetTask = pipeline.defer.operations.run.haute.naomi.prepare_dataset.v1({
                input: {
                    data: [
                        {
                            garmentImageId: garmentImage.id,
                            outputImageId: outputImage.id,
                            prompt: 'E2E Test LoRA Training - Garment Model',
                            category: 'upper_body',
                        },
                    ],
                    returnStream: true,
                },
            });
            const awaitedPrepareDatasetTask = pipeline.defer.operations.wait(prepareDatasetTask.result);

            const trainNaomiTask = pipeline.defer.operations.run.haute.naomi.train.v1({
                input: {
                    datasetFileId: awaitedPrepareDatasetTask.result.output.data.fileId,
                    epochs: 1, // Minimal training for testing
                },
            });

            const awaitedTrainNaomiTask = pipeline.defer.operations.wait(trainNaomiTask.result);

            pipeline.setOutputRef(awaitedTrainNaomiTask.result.output.data.loraId);

            return pipeline;
        });

        // Create the pipeline
        const createdPipeline = await sdk.pipelines.createFromTemplate(pipelineData);
        expect(createdPipeline).toBeDefined();
        expect(createdPipeline.id).toBeDefined();

        // Wait for the training pipeline to complete
        const completedPipeline = await sdk.pipelines.wait(createdPipeline, 600_000);
        expect(completedPipeline).toBeDefined();
        expect(completedPipeline.status).toBe(PipelineDtoStatus.completed);
        expect(completedPipeline.output).toBeDefined();

        // Save the trained LoRA ID from pipeline output
        createdLoraId = String(completedPipeline.output);
        expect(createdLoraId).toBeDefined();
        expect(typeof createdLoraId).toBe('string');

        // Verify the LoRA exists in the API
        const createdLora = await sdk.loras.get(createdLoraId);
        expect(createdLora).toBeDefined();
        expect(createdLora!.id).toBe(createdLoraId);
        expect(createdLora!.modelType).toBe(LoraDtoModelType.naomi);
        expect(createdLora!.status).toBe(LoraDtoStatus.succeeded);
        expect(createdLora!.completedAt).toBeDefined();
        expect(createdLora!.weightsUrl).toBeDefined();
    }, 600_000);

    it('should list loras', async () => {
        const result = await sdk.loras.list();

        expect(result).toBeDefined();
        expect(result.data).toBeDefined();
        expect(Array.isArray(result.data)).toBe(true);
        expect(result.pageInfo).toBeDefined();

        // Ensure created LoRA is present in the list
        expect(createdLoraId).toBeDefined();
        const found = result.data.find((l) => l.id === createdLoraId);
        expect(found, 'Created LoRA should be present in list() results').toBeDefined();

        // Validate structure for every item in the list
        for (const lora of result.data) {
            expect(lora.id).toBeDefined();
            expect(typeof lora.id).toBe('string');
            expect(lora.status).toBeDefined();
            expect(Object.values(LoraDtoStatus)).toContain(lora.status);
            expect(lora.modelType).toBeDefined();
            expect(Object.values(LoraDtoModelType)).toContain(lora.modelType);
            expect(lora.createdAt).toBeDefined();
            expect(typeof lora.createdAt).toBe('string');
            expect(lora.updatedAt).toBeDefined();
            expect(typeof lora.updatedAt).toBe('string');

            if (lora.alias) expect(typeof lora.alias).toBe('string');
            if (lora.weightsUrl) expect(typeof lora.weightsUrl).toBe('string');
            if (lora.error) expect(typeof lora.error).toBe('string');
            if (lora.completedAt) expect(typeof lora.completedAt).toBe('string');
        }
    }, 30_000);

    it('should list loras with filters and verify each item matches created LoRA type', async () => {
        const result = await sdk.loras.list({
            modelType: LoraDtoModelType.naomi,
        });

        expect(result).toBeDefined();
        expect(result.data).toBeDefined();
        expect(Array.isArray(result.data)).toBe(true);
        expect(result.pageInfo).toBeDefined();

        // All items should be of the requested modelType and have proper structure
        for (const lora of result.data) {
            expect(lora.modelType).toBe(LoraDtoModelType.naomi);
            expect(lora.id).toBeDefined();
            expect(typeof lora.id).toBe('string');
            expect(Object.values(LoraDtoStatus)).toContain(lora.status);
            expect(lora.createdAt).toBeDefined();
            expect(typeof lora.createdAt).toBe('string');
            expect(lora.updatedAt).toBeDefined();
            expect(typeof lora.updatedAt).toBe('string');

            if (lora.alias) expect(typeof lora.alias).toBe('string');
            if (lora.weightsUrl) expect(typeof lora.weightsUrl).toBe('string');
            if (lora.error) expect(typeof lora.error).toBe('string');
            if (lora.completedAt) expect(typeof lora.completedAt).toBe('string');
        }

        // Ensure created LoRA (which is Naomi) is present in filtered results
        expect(createdLoraId).toBeDefined();
        const hasCreated = result.data.some((l) => l.id === createdLoraId);
        expect(hasCreated).toBe(true);
    }, 30_000);

    it('should get a specific lora by id', async () => {
        expect(createdLoraId).toBeDefined();
        const result = await sdk.loras.get(createdLoraId!);

        expect(result).toBeDefined();
        expect(result!.id).toBe(createdLoraId);
        expect(result!.status).toBeDefined();
        expect(result!.modelType).toBeDefined();
        expect(result!.createdAt).toBeDefined();
        expect(result!.updatedAt).toBeDefined();
    }, 30_000);

    it('should handle getting non-existent lora gracefully', async () => {
        const result = await sdk.loras.get(v4());
        expect(result).toBeNull();
    }, 30_000);

    it('should verify lora data structure for every listed item', async () => {
        const result = await sdk.loras.list();

        expect(result.data.length).toBeGreaterThan(0);

        for (const lora of result.data) {
            // Required fields
            expect(lora.id).toBeDefined();
            expect(typeof lora.id).toBe('string');
            expect(lora.status).toBeDefined();
            expect(Object.values(LoraDtoStatus)).toContain(lora.status);
            expect(lora.modelType).toBeDefined();
            expect(Object.values(LoraDtoModelType)).toContain(lora.modelType);
            expect(lora.createdAt).toBeDefined();
            expect(typeof lora.createdAt).toBe('string');
            expect(lora.updatedAt).toBeDefined();
            expect(typeof lora.updatedAt).toBe('string');

            // Optional fields
            if (lora.alias) {
                expect(typeof lora.alias).toBe('string');
            }
            if (lora.weightsUrl) {
                expect(typeof lora.weightsUrl).toBe('string');
            }
            if (lora.error) {
                expect(typeof lora.error).toBe('string');
            }
            if (lora.completedAt) {
                expect(typeof lora.completedAt).toBe('string');
            }
        }
    }, 30_000);

    it('should use trained LoRA in a Naomi generation pipeline', async () => {
        expect(createdLoraId).toBeDefined();
        const loraId = createdLoraId!;

        // Upload images for generation
        const garmentImagePath = path.join(__dirname, 'assets', 'garment.png');
        const garmentImage = await sdk.images.createFromFile(garmentImagePath);

        const poseImagePath = path.join(__dirname, 'assets', 'pose.png');
        const poseImage = await sdk.images.createFromFile(poseImagePath);

        // Create generation pipeline using the LoRA
        const pipelineData = sdk.pipelines.constructTemplate((pipeline) => {
            const estimationTask = pipeline.defer.operations.run.poseEstimation.v1({
                input: {
                    imageId: poseImage.id,
                },
            });
            const awaitedEstimationTask = pipeline.defer.operations.wait(estimationTask.result);

            const naomiTask = pipeline.defer.operations.run.haute.naomi.v1({
                input: {
                    prompt: 'E2E Test Generation using trained LoRA',
                    mode: 'apparel_to_model',
                    category: 'upper_body',
                    garmentImageId: garmentImage.id,
                    poseId: awaitedEstimationTask.result.output.data.poseId,
                    seed: 12345,
                    loraIds: [loraId],
                },
            });
            const awaitedNaomiTask = pipeline.defer.operations.wait(naomiTask.result);

            pipeline.setOutputRef(awaitedNaomiTask.result.output.imageId);

            return pipeline;
        });

        // Create the generation pipeline
        const createdPipeline = await sdk.pipelines.createFromTemplate(pipelineData);

        expect(createdPipeline).toBeDefined();
        expect(createdPipeline.id).toBeDefined();
        console.log(`Generation pipeline created: ${createdPipeline.id} using LoRA: ${loraId}`);

        // Wait for the generation pipeline to complete
        const completedPipeline = await sdk.pipelines.wait(createdPipeline, 300_000);

        expect(completedPipeline).toBeDefined();
        expect(completedPipeline.status).toBe(PipelineDtoStatus.completed);
        expect(completedPipeline.output).toBeDefined();
        expect(typeof completedPipeline.output).toBe('string');
    }, 300_000);

    it('should monitor LoRA training progress through status changes', async () => {
        // Get list of LoRAs and check for ones in different training states
        const lorasList = await sdk.loras.list();

        const processingLora = lorasList.data.find(
            (lora) => lora.status === LoraDtoStatus.processing || lora.status === LoraDtoStatus.starting,
        );

        if (processingLora) {
            // Verify the LoRA details
            const loraDetails = await sdk.loras.get(processingLora.id);
            expect(loraDetails).toBeDefined();
            expect(loraDetails!.id).toBe(processingLora.id);
            expect([LoraDtoStatus.starting, LoraDtoStatus.processing]).toContain(loraDetails!.status);
            expect(loraDetails!.createdAt).toBeDefined();
            expect(loraDetails!.updatedAt).toBeDefined();

            // Processing LoRAs should not have weights URL yet
            if (loraDetails!.status === LoraDtoStatus.processing || loraDetails!.status === LoraDtoStatus.starting) {
                expect(loraDetails!.weightsUrl).toBeUndefined();
                expect(loraDetails!.completedAt).toBeUndefined();
            }
        }

        // Check for successful LoRAs to verify completed training
        const succeededLora = lorasList.data.find((lora) => lora.status === LoraDtoStatus.succeeded);

        if (succeededLora) {
            const loraDetails = await sdk.loras.get(succeededLora.id);
            expect(loraDetails).toBeDefined();
            expect(loraDetails!.status).toBe(LoraDtoStatus.succeeded);
            expect(loraDetails!.weightsUrl).toBeDefined();
            expect(loraDetails!.completedAt).toBeDefined();
        }

        // Check for failed LoRAs to verify error handling
        const failedLora = lorasList.data.find((lora) => lora.status === LoraDtoStatus.failed);

        if (failedLora) {
            const loraDetails = await sdk.loras.get(failedLora.id);
            expect(loraDetails).toBeDefined();
            expect(loraDetails!.status).toBe(LoraDtoStatus.failed);
            expect(loraDetails!.error).toBeDefined();
            expect(typeof loraDetails!.error).toBe('string');
        }

        // Ensure we have some LoRAs to test with
        expect(lorasList.data.length).toBeGreaterThan(0);
    }, 60_000);
});
