import { beforeAll, describe, expect, it } from 'vitest';
import { createTestSdk } from '../test-utils';
import { v4 } from 'uuid';
import { EchoV1Response, PipelineDtoStatus, TaskDto } from '../../autogenerated/schemas';
import { TaskOutput } from '@hautechai/pipelines/dist/pipeline';

describe('Pipelines API E2E Tests', () => {
    let sdk = createTestSdk();
    let createdPipelineId: string;

    beforeAll(async () => {
        const testPipeline = await sdk.pipelines.create({
            tasks: [
                {
                    id: 'test-task-1',
                    dependencies: [],
                    args: [
                        {
                            testData: 'e2e test pipeline',
                        },
                    ],
                    method: ['echo', 'v1'],
                },
            ],
            metadata: {
                description: 'Test pipeline for e2e testing',
                testType: 'e2e',
            },
        });
        createdPipelineId = testPipeline.id;
    });

    describe('Pipeline CRUD Operations', () => {
        it('should create a new pipeline', async () => {
            const pipelineData = {
                tasks: [
                    {
                        id: 'creation-task-1',
                        dependencies: [],
                        args: [
                            {
                                testData: 'new pipeline test',
                            },
                        ],
                        method: ['echo', 'v1'],
                    },
                ],
                metadata: {
                    description: 'New pipeline creation test',
                    testType: 'creation',
                },
            };

            const result = await sdk.pipelines.create(pipelineData);

            expect(result).toBeDefined();
            expect(result.id).toBeDefined();
            expect(typeof result.id).toBe('string');
            expect(result.id.length).toBeGreaterThan(0);
            expect(result.kind).toBeDefined();
            expect(result.status).toBeDefined();
            expect(Object.values(PipelineDtoStatus)).toContain(result.status);
            expect(result.createdAt).toBeDefined();
            expect(result.updatedAt).toBeDefined();
            expect(result.creatorId).toBeDefined();
            expect(result.metadata).toBeDefined();
            expect(result.tasks).toBeDefined();
            expect(Array.isArray(result.tasks)).toBe(true);
            expect(result.estimatedCredits).toBeDefined();
            expect(result.consumedCredits).toBeDefined();
        });

        it('should get a specific pipeline by ID', async () => {
            const result = await sdk.pipelines.get(createdPipelineId);

            expect(result).toBeDefined();
            expect(result!.id).toBe(createdPipelineId);
            expect(result!.status).toBeDefined();
            expect(Object.values(PipelineDtoStatus)).toContain(result!.status);
            expect(result!.createdAt).toBeDefined();
            expect(result!.updatedAt).toBeDefined();
            expect(result!.creatorId).toBeDefined();
            expect(result!.kind).toBeDefined();
            expect(result!.metadata).toBeDefined();
            expect(result!.tasks).toBeDefined();
            expect(Array.isArray(result!.tasks)).toBe(true);
            expect(result!.estimatedCredits).toBeDefined();
            expect(result!.consumedCredits).toBeDefined();
            expect(result!.state).toBeDefined();
        });

        it('should get a non-existent pipeline', async () => {
            const result = await sdk.pipelines.get(v4());
            expect(result).toBeNull();
        });

        it('should list pipelines', async () => {
            const result = await sdk.pipelines.list();

            expect(result).toBeDefined();
            expect(result.data).toBeDefined();
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.pageInfo).toBeDefined();

            const createdPipeline = result.data.find((pipeline) => pipeline.id === createdPipelineId);
            expect(createdPipeline!.id).toBe(createdPipelineId);
            expect(createdPipeline!.status).toBeDefined();
            expect(Object.values(PipelineDtoStatus)).toContain(createdPipeline!.status);
        });

        it('should list pipelines with pagination', async () => {
            const result = await sdk.pipelines.list({
                limit: 2,
                cursor: undefined, // First page
            });

            expect(result).toBeDefined();
            expect(result.data).toBeDefined();
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data.length).toBeLessThanOrEqual(2);
            expect(result.pageInfo).toBeDefined();

            const nextPageResult = await sdk.pipelines.list({
                limit: 2,
                cursor: result.pageInfo.nextCursor,
            });

            expect(nextPageResult).toBeDefined();
            expect(nextPageResult.data).toBeDefined();
            expect(Array.isArray(nextPageResult.data)).toBe(true);
            expect(nextPageResult.data.length).toBeLessThanOrEqual(2);
            expect(nextPageResult.pageInfo).toBeDefined();
        });
    });

    describe('Pipeline Wait Functionality', () => {
        it('should wait for pipeline completion', async () => {
            // Create a new pipeline for this test
            const testPipeline = await sdk.pipelines.create({
                tasks: [
                    {
                        id: 'wait-task-1',
                        dependencies: [],
                        args: [
                            {
                                testData: 'wait test pipeline',
                            },
                        ],
                        method: ['echo', 'v1'],
                    },
                ],
                metadata: {
                    description: 'Pipeline for testing wait functionality',
                    testType: 'wait',
                },
            });

            const result = await sdk.pipelines.wait(testPipeline, 30000);

            expect(result).toBeDefined();
            expect(result.id).toBe(testPipeline.id);
            expect(result.status).not.toBe(PipelineDtoStatus.pending);
            expect([PipelineDtoStatus.completed, PipelineDtoStatus.failed]).toContain(result.status);
        });
    });

    describe('Pipeline Construction and Execution', () => {
        it('should construct a pipeline using the fluent API and run it', async () => {
            const pipelineData = sdk.pipelines.constructTemplate((pipeline) => {
                const echoTask = pipeline.defer.operations.run.echo.v1({
                    input: {
                        text: pipeline.inputRef?.message || 'fallback text',
                    },
                });

                const awaitedEcho = pipeline.defer.operations.wait<EchoV1Response>(echoTask.result);

                // Set the output to reference the echo task result
                pipeline.output = awaitedEcho.result.output;

                return pipeline;
            });

            pipelineData.input = {
                message: 'Hello from constructed pipeline!',
            };

            // Create the pipeline using the API
            const createdPipeline = await sdk.pipelines.createFromTemplate(pipelineData);

            expect(createdPipeline).toBeDefined();
            expect(createdPipeline.id).toBeDefined();
            expect(typeof createdPipeline.id).toBe('string');
            expect(createdPipeline.tasks).toBeDefined();
            expect(Array.isArray(createdPipeline.tasks)).toBe(true);
            expect(createdPipeline.tasks.length).toBeGreaterThan(0);
            expect(createdPipeline.status).toBeDefined();
            expect(Object.values(PipelineDtoStatus)).toContain(createdPipeline.status);

            // Wait for the pipeline to complete
            const completedPipeline = await sdk.pipelines.wait(createdPipeline, 30000);

            expect(completedPipeline).toBeDefined();
            expect(completedPipeline.id).toBe(createdPipeline.id);
            expect(completedPipeline.status).toBe(PipelineDtoStatus.completed);
            expect(completedPipeline.output).toBeDefined();
            expect(completedPipeline.output?.text).toEqual(pipelineData.input.message);
        });

        it('should construct a pipeline with multiple tasks and dependencies', async () => {
            // Build a more complex pipeline with task dependencies
            let pipelineData: any;

            sdk.pipelines.constructTemplate((pipeline) => {
                // First task
                const firstTask = pipeline.defer.operations.run.echo.v1({
                    input: {
                        text: 'First task output',
                    },
                });

                // Second task that depends on the first task
                const secondTask = pipeline.after(firstTask.id).operations.run.echo.v1({
                    input: {
                        text: 'Second task using first task result',
                    },
                });

                // Set the final output
                pipeline.output = secondTask.result;

                // Extract the data we need for the API call
                pipelineData = {
                    tasks: pipeline.compactTasks(),
                    metadata: {
                        description: 'Multi-task pipeline with dependencies',
                        testType: 'construct-multi',
                    },
                    outputRef: pipeline.outputRef,
                };

                return pipeline;
            });

            // Create and verify the pipeline
            const createdPipeline = await sdk.pipelines.create(pipelineData);

            expect(createdPipeline).toBeDefined();
            expect(createdPipeline.id).toBeDefined();
            expect(createdPipeline.tasks).toBeDefined();
            expect(createdPipeline.tasks.length).toBe(2); // Should have 2 tasks

            // Check that the second task has a dependency on the first
            const tasks = createdPipeline.tasks;
            const taskWithDependency = tasks.find((task) => task.dependencies.length > 0);
            expect(taskWithDependency).toBeDefined();
            expect(taskWithDependency!.dependencies.length).toBe(1);

            // Wait for completion
            const completedPipeline = await sdk.pipelines.wait(createdPipeline, 30000);
            expect(completedPipeline.status).not.toBe(PipelineDtoStatus.pending);
        });
    });

    describe('Error Handling', () => {
        it('should handle invalid pipeline ID in wait', async () => {
            const invalidPipeline = {
                id: v4(),
                status: PipelineDtoStatus.pending,
            } as any;

            try {
                await sdk.pipelines.wait(invalidPipeline, 5000);
                expect(true).toBe(false); // Should not reach here
            } catch (error) {
                expect(error).toBeDefined();
                expect((error as Error).message).toBe('Pipeline not found');
            }
        });

        it('should handle invalid pipeline creation data', async () => {
            try {
                await sdk.pipelines.create({
                    tasks: [
                        {
                            id: null as any, // Invalid task ID
                            dependencies: null as any, // Invalid dependencies
                            args: null as any, // Invalid args
                            method: null as any, // Invalid method
                        },
                    ],
                    metadata: null as any,
                });
                expect(true).toBe(false); // Should not reach here
            } catch (error) {
                expect(error).toBeDefined();
            }
        });
    });
});
