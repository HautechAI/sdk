import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createTokenSigner } from '../../token';
import * as jose from 'jose';
import { MethodsPermissions } from '../../autogenerated/permissions';

// Mock the jose library
vi.mock('jose', () => ({
    importPKCS8: vi.fn(),
    SignJWT: vi.fn(),
}));

describe('token', () => {
    let mockPrivateKey: any;
    let mockSignJWT: any;
    let mockJoseImportPKCS8: any;

    beforeEach(() => {
        vi.clearAllMocks();

        mockPrivateKey = { type: 'private', format: 'pkcs8' };
        mockSignJWT = {
            setIssuedAt: vi.fn().mockReturnThis(),
            setExpirationTime: vi.fn().mockReturnThis(),
            setProtectedHeader: vi.fn().mockReturnThis(),
            sign: vi.fn().mockResolvedValue('mock-jwt-token'),
        };

        mockJoseImportPKCS8 = vi.mocked(jose.importPKCS8);
        mockJoseImportPKCS8.mockResolvedValue(mockPrivateKey);

        vi.mocked(jose.SignJWT).mockReturnValue(mockSignJWT);
    });

    describe('createTokenSigner', () => {
        const validOptions = {
            appId: 'test-app-id',
            appKeyId: 'test-key-id',
            appKeySecret: 'testkeysecrettestkeysecrettestkeysecrettestkeysecret',
        };

        describe('validation', () => {
            it('should throw error when appId is missing', () => {
                expect(() => createTokenSigner({ ...validOptions, appId: '' })).toThrow('appId is required');
            });

            it('should throw error when appId is empty string', () => {
                expect(() => createTokenSigner({ ...validOptions, appId: '' })).toThrow('appId is required');
            });

            it('should throw error when appKeyId is missing', () => {
                expect(() => createTokenSigner({ ...validOptions, appKeyId: '' })).toThrow('appKeyId is required');
            });

            it('should throw error when appKeyId is empty string', () => {
                expect(() => createTokenSigner({ ...validOptions, appKeyId: '' })).toThrow('appKeyId is required');
            });

            it('should throw error when appKeySecret is missing', () => {
                expect(() => createTokenSigner({ ...validOptions, appKeySecret: '' })).toThrow(
                    'appKeySecret is required',
                );
            });

            it('should throw error when appKeySecret is empty string', () => {
                expect(() => createTokenSigner({ ...validOptions, appKeySecret: '' })).toThrow(
                    'appKeySecret is required',
                );
            });

            it('should create token signer with valid options', () => {
                const signer = createTokenSigner(validOptions);
                expect(signer).toHaveProperty('createAccountToken');
                expect(signer).toHaveProperty('createRootToken');
            });
        });

        describe('createAccountToken', () => {
            let signer: ReturnType<typeof createTokenSigner>;

            beforeEach(() => {
                signer = createTokenSigner(validOptions);
            });

            it('should create account token with basic parameters', async () => {
                const token = await signer.createAccountToken({
                    accountId: 'test-account-id',
                    expiresInSeconds: 3600,
                });

                expect(token).toBe('mock-jwt-token');
                expect(jose.importPKCS8).toHaveBeenCalledWith(
                    expect.stringContaining('-----BEGIN PRIVATE KEY-----'),
                    'RS256',
                );
                expect(jose.SignJWT).toHaveBeenCalledWith({
                    iss: 'test-app-id',
                    permissions: [],
                    sub: 'test-account-id',
                    kind: 'core-api',
                });
                expect(mockSignJWT.setExpirationTime).toHaveBeenCalledWith('3600s');
                expect(mockSignJWT.setProtectedHeader).toHaveBeenCalledWith({
                    alg: 'RS256',
                    kid: 'test-key-id',
                });
            });

            it('should create account token with permissions', async () => {
                const permissions: Partial<MethodsPermissions> = {
                    accounts: {
                        create: true,
                        read: true,
                        list: false,
                        update: false,
                    },
                    balances: {
                        read: true,
                        update: false,
                        self: {
                            read: true,
                            update: false,
                        },
                    },
                };

                const token = await signer.createAccountToken({
                    accountId: 'test-account-id',
                    expiresInSeconds: 7200,
                    permissions,
                });

                expect(token).toBe('mock-jwt-token');
                expect(jose.SignJWT).toHaveBeenCalledWith({
                    iss: 'test-app-id',
                    permissions: ['accounts:create', 'accounts:read', 'balances:read', 'balances:self:read'],
                    sub: 'test-account-id',
                    kind: 'core-api',
                });
                expect(mockSignJWT.setExpirationTime).toHaveBeenCalledWith('7200s');
            });

            it('should create account token with empty permissions object', async () => {
                const token = await signer.createAccountToken({
                    accountId: 'test-account-id',
                    expiresInSeconds: 1800,
                    permissions: {},
                });

                expect(token).toBe('mock-jwt-token');
                expect(jose.SignJWT).toHaveBeenCalledWith({
                    iss: 'test-app-id',
                    permissions: [],
                    sub: 'test-account-id',
                    kind: 'core-api',
                });
            });

            it('should create account token with complex nested permissions', async () => {
                const permissions: Partial<MethodsPermissions> = {
                    collections: {
                        create: true,
                        read: false,
                        items: {
                            add: true,
                            read: true,
                            remove: false,
                        },
                        metadata: {
                            update: true,
                        },
                    },
                    resources: {
                        access: {
                            list: true,
                            read: false,
                            grant: true,
                            revoke: false,
                            attach: false,
                            detach: true,
                        },
                    },
                };

                const token = await signer.createAccountToken({
                    accountId: 'test-account-id',
                    expiresInSeconds: 3600,
                    permissions,
                });

                expect(jose.SignJWT).toHaveBeenCalledWith({
                    iss: 'test-app-id',
                    permissions: [
                        'collections:create',
                        'collections:items:add',
                        'collections:items:read',
                        'collections:metadata:update',
                        'resources:access:list',
                        'resources:access:grant',
                        'resources:access:detach',
                    ],
                    sub: 'test-account-id',
                    kind: 'core-api',
                });
            });
        it('should allow overriding kind to directory-api for account token', async () => {
            await signer.createAccountToken({
                accountId: 'test-account-id',
                expiresInSeconds: 3600,
                kind: 'directory-api',
            });

            expect(jose.SignJWT).toHaveBeenCalledWith({
                iss: 'test-app-id',
                permissions: [],
                sub: 'test-account-id',
                kind: 'directory-api',
            });
        });
        });

        describe('createRootToken', () => {
            let signer: ReturnType<typeof createTokenSigner>;

            beforeEach(() => {
                signer = createTokenSigner(validOptions);
            });

            it('should create root token with specified expiration', async () => {
                const token = await signer.createRootToken({
                    expiresInSeconds: 7200,
                });

                expect(token).toBe('mock-jwt-token');
                expect(jose.SignJWT).toHaveBeenCalledWith({
                    iss: 'test-app-id',
                    permissions: ['*'],
                    kind: 'core-api',
                });
                expect(mockSignJWT.setExpirationTime).toHaveBeenCalledWith('7200s');
                expect(mockSignJWT.setProtectedHeader).toHaveBeenCalledWith({
                    alg: 'RS256',
                    kid: 'test-key-id',
                });
            });

            it('should create root token with default expiration when not specified', async () => {
                const token = await signer.createRootToken({
                    expiresInSeconds: undefined as any,
                });

                expect(token).toBe('mock-jwt-token');
                expect(mockSignJWT.setExpirationTime).toHaveBeenCalledWith('3600s');
            });
        });
    });

    describe('private key formatting', () => {
        let signer: ReturnType<typeof createTokenSigner>;

        beforeEach(() => {
            signer = createTokenSigner({
                appId: 'test-app-id',
                appKeyId: 'test-key-id',
                appKeySecret: 'testkeysecrettestkeysecrettestkeysecrettestkeysecret',
            });
        });

        it('should format private key correctly', async () => {
            await signer.createRootToken({ expiresInSeconds: 3600 });

            expect(jose.importPKCS8).toHaveBeenCalledWith(
                expect.stringMatching(/^-----BEGIN PRIVATE KEY-----\n[\s\S]*\n-----END PRIVATE KEY-----$/),
                'RS256',
            );

            const formattedKey = (jose.importPKCS8 as any).mock.calls[0][0];
            expect(formattedKey).toContain('-----BEGIN PRIVATE KEY-----');
            expect(formattedKey).toContain('-----END PRIVATE KEY-----');

            // Check that the key body is properly formatted in 64-character lines
            const keyBody = formattedKey
                .replace('-----BEGIN PRIVATE KEY-----\n', '')
                .replace('\n-----END PRIVATE KEY-----', '');
            const lines = keyBody.split('\n');
            lines.forEach((line: string) => {
                expect(line.length).toBeLessThanOrEqual(64);
            });
        });

        it('should handle different key lengths', async () => {
            const shortKeySigner = createTokenSigner({
                appId: 'test-app-id',
                appKeyId: 'test-key-id',
                appKeySecret: 'shortkey',
            });

            await shortKeySigner.createRootToken({ expiresInSeconds: 3600 });

            const formattedKey = (jose.importPKCS8 as any).mock.calls[0][0];
            expect(formattedKey).toBe('-----BEGIN PRIVATE KEY-----\nshortkey\n-----END PRIVATE KEY-----');
        });
    });

    describe('serializePermissions function behavior', () => {
        let signer: ReturnType<typeof createTokenSigner>;

        beforeEach(() => {
            signer = createTokenSigner({
                appId: 'test-app-id',
                appKeyId: 'test-key-id',
                appKeySecret: 'testkeysecrettestkeysecrettestkeysecrettestkeysecret',
            });
        });

        it('should handle empty permissions', async () => {
            await signer.createAccountToken({
                accountId: 'test-account-id',
                expiresInSeconds: 3600,
                permissions: {},
            });

            expect(jose.SignJWT).toHaveBeenCalledWith({
                iss: 'test-app-id',
                permissions: [],
                sub: 'test-account-id',
                kind: 'core-api',
            });
        });

        it('should handle flat permissions structure', async () => {
            const permissions = {
                accounts: {
                    create: true,
                    read: false,
                    list: true,
                    update: false,
                },
            } as Partial<MethodsPermissions>;

            await signer.createAccountToken({
                accountId: 'test-account-id',
                expiresInSeconds: 3600,
                permissions,
            });

            expect(jose.SignJWT).toHaveBeenCalledWith({
                iss: 'test-app-id',
                permissions: ['accounts:create', 'accounts:list'],
                sub: 'test-account-id',
                kind: 'core-api',
            });
        });

        it('should handle deeply nested permissions', async () => {
            const permissions = {
                balances: {
                    read: false,
                    update: false,
                    self: {
                        read: true,
                        update: true,
                    },
                },
            } as Partial<MethodsPermissions>;

            await signer.createAccountToken({
                accountId: 'test-account-id',
                expiresInSeconds: 3600,
                permissions,
            });

            expect(jose.SignJWT).toHaveBeenCalledWith({
                iss: 'test-app-id',
                permissions: ['balances:self:read', 'balances:self:update'],
                sub: 'test-account-id',
                kind: 'core-api',
            });
        });

        it('should handle mixed permission levels', async () => {
            const permissions = {
                accounts: {
                    create: true,
                    read: false,
                    list: false,
                    update: false,
                },
                images: {
                    create: false,
                    read: true,
                },
                collections: {
                    create: false,
                    read: true,
                    items: {
                        add: true,
                        read: false,
                        remove: true,
                    },
                    metadata: {
                        update: false,
                    },
                },
            } as Partial<MethodsPermissions>;

            await signer.createAccountToken({
                accountId: 'test-account-id',
                expiresInSeconds: 3600,
                permissions,
            });

            expect(jose.SignJWT).toHaveBeenCalledWith({
                iss: 'test-app-id',
                permissions: [
                    'accounts:create',
                    'images:read',
                    'collections:read',
                    'collections:items:add',
                    'collections:items:remove',
                ],
                sub: 'test-account-id',
                kind: 'core-api',
            });
        });
    });

    describe('error handling', () => {
        it('should handle jose library errors', async () => {
            const mockError = new Error('Invalid private key');
            mockJoseImportPKCS8.mockRejectedValue(mockError);

            const signer = createTokenSigner({
                appId: 'test-app-id',
                appKeyId: 'test-key-id',
                appKeySecret: 'invalid-key',
            });

            await expect(signer.createRootToken({ expiresInSeconds: 3600 })).rejects.toThrow('Invalid private key');
        });

        it('should handle signing errors', async () => {
            const mockError = new Error('Signing failed');
            mockSignJWT.sign.mockRejectedValue(mockError);

            const signer = createTokenSigner({
                appId: 'test-app-id',
                appKeyId: 'test-key-id',
                appKeySecret: 'testkeysecrettestkeysecrettestkeysecrettestkeysecret',
            });

            await expect(
                signer.createAccountToken({
                    accountId: 'test-account-id',
                    expiresInSeconds: 3600,
                }),
            ).rejects.toThrow('Signing failed');
        });
    });
});
