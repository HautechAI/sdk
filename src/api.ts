import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import * as qs from 'qs';
import { getHautechAPI } from './autogenerated';
import { Config } from './config';
import { DeepWrap, SDK } from './types';
import vitestConfig from '../vitest.e2e.config';

export type CoreApi = ReturnType<typeof getHautechAPI>;
export const api = getHautechAPI();

const looksLikeAxiosRequestOptions = (arg: unknown): arg is AxiosRequestConfig =>
    typeof arg === 'object' && arg !== null && ('headers' in arg || 'baseURL' in arg || 'timeout' in arg);

export const wrapApiCall = <Fn extends (...args: any[]) => Promise<AxiosResponse<any>>>(fn: Fn, config: Config) => {
    const wrapped = async function (this: SDK, ...args: Parameters<Fn>) {
        if ((fn as any).__customMethodWrapper) {
            return fn.call(this, ...args);
        }

        const token = await config.authToken();
        const baseOptions: AxiosRequestConfig = {
            baseURL: config.baseUrl,
            headers: {
                Authorization: `Bearer ${token}`,
            },
            timeout: vitestConfig.test?.testTimeout,
        };

        const finalArgs = [...args];
        const lastParamIndex = fn.length - 1;

        if (looksLikeAxiosRequestOptions(args[lastParamIndex])) {
            finalArgs[lastParamIndex] = {
                ...args[lastParamIndex],
                ...baseOptions,
                headers: {
                    ...(args[lastParamIndex]?.headers ?? {}),
                    Authorization: `Bearer ${token}`,
                },
            };
        } else {
            while (finalArgs.length < fn.length - 1) {
                finalArgs.push(undefined);
            }
            finalArgs.push(baseOptions);
        }

        try {
            const res = await fn.call(this, ...finalArgs);
            return typeof res === 'object' && 'headers' in res ? res.data : res;
        } catch (err: any) {
            if (axios.isAxiosError(err)) {
                err.message = `Request error: ${err.message || 'Unknown error'}.\n${
                    err.response?.data?.message || JSON.stringify(err.response?.data) || ''
                }`;
            }
            throw err;
        }
    };

    (wrapped as any).__isWrapped = true;
    return wrapped;
};

export const wrapApiCallNullable = <Fn extends (...args: any[]) => Promise<AxiosResponse<any>>>(
    fn: Fn,
): ((
    ...args: Parameters<Fn>
) => Promise<Awaited<ReturnType<Fn>> extends AxiosResponse<infer R, infer T> ? AxiosResponse<R | null, T> : never>) => {
    const wrapped = async (
        ...args: Parameters<Fn>
    ): Promise<
        Awaited<ReturnType<Fn>> extends AxiosResponse<infer R, infer T> ? AxiosResponse<R | null, T> : never
    > => {
        try {
            const res = (await fn(...args)) as Awaited<ReturnType<Fn>>;
            if (res && 'data' in res) {
                return { ...res, data: res.data } as any;
            }
            return res as any;
        } catch (err: any) {
            if (axios.isAxiosError(err) && err.response?.status === 404) {
                return {
                    ...(err.response || {}),
                    data: null,
                } as any;
            }
            throw err;
        }
    };

    return wrapped;
};

export const wrapCustomMethod = <Fn extends (...args: any[]) => Promise<any>>(fn: Fn): Fn => {
    (fn as any).__customMethodWrapper = true;
    return fn;
};

const isRawAxiosFn = (fn: any): fn is (...args: any[]) => Promise<AxiosResponse<any>> => {
    return typeof fn === 'function' && fn.__isWrapped !== true;
};

export const wrapApiCallDeep = <T>(obj: T, config: Config, sdkContext?: Partial<SDK>): DeepWrap<T> => {
    if (isRawAxiosFn(obj)) {
        const wrapped: any = wrapApiCall(obj, config);
        return sdkContext ? wrapped.bind(sdkContext) : wrapped;
    }

    if (typeof obj === 'function') {
        return sdkContext ? obj.bind(sdkContext) : obj;
    }

    if (typeof obj === 'object' && obj !== null) {
        const result: any = {};
        for (const [key, value] of Object.entries(obj)) {
            result[key] = wrapApiCallDeep(value, config, sdkContext);
        }
        return result;
    }

    return obj as any;
};

export const axiosMutator: <R>(
    config: AxiosRequestConfig,
    options?: AxiosRequestConfig,
) => Promise<AxiosResponse<R>> = async (config, options) => {
    return axios.request({
        ...config,
        ...options,
        paramsSerializer: (params) => {
            return qs.stringify(params, { arrayFormat: 'repeat' });
        },
    });
};
