/* tslint:disable */
/* eslint-disable */
/**
 * Hautech API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountEntity
 */
export interface AccountEntity {
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof AccountEntity
     */
    'balance': object;
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'type': AccountEntityTypeEnum;
}

export const AccountEntityTypeEnum = {
    Root: 'root',
    User: 'user'
} as const;

export type AccountEntityTypeEnum = typeof AccountEntityTypeEnum[keyof typeof AccountEntityTypeEnum];

/**
 * 
 * @export
 * @interface AddAccountToGroupControllerParamsDto
 */
export interface AddAccountToGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'role': AddAccountToGroupControllerParamsDtoRoleEnum;
}

export const AddAccountToGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type AddAccountToGroupControllerParamsDtoRoleEnum = typeof AddAccountToGroupControllerParamsDtoRoleEnum[keyof typeof AddAccountToGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface AddAccountToGroupParamsDto
 */
export interface AddAccountToGroupParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupParamsDto
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupParamsDto
     */
    'role': AddAccountToGroupParamsDtoRoleEnum;
}

export const AddAccountToGroupParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type AddAccountToGroupParamsDtoRoleEnum = typeof AddAccountToGroupParamsDtoRoleEnum[keyof typeof AddAccountToGroupParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface AddBalanceControllerParamsDto
 */
export interface AddBalanceControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddBalanceControllerParamsDto
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof AddBalanceControllerParamsDto
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface AddBalanceParamsDto
 */
export interface AddBalanceParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddBalanceParamsDto
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof AddBalanceParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AddBalanceParamsDto
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface AddItemsToCollectionControllerParamsDto
 */
export interface AddItemsToCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddItemsToCollectionParamsDto
 */
export interface AddItemsToCollectionParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddItemsToCollectionParamsDto
     */
    'collectionId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToCollectionParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddItemsToStackControllerParamsDto
 */
export interface AddItemsToStackControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToStackControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddItemsToStackParamsDto
 */
export interface AddItemsToStackParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddItemsToStackParamsDto
     */
    'stackId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToStackParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AnimateCreatomateV1Input
 */
export interface AnimateCreatomateV1Input {
    /**
     * 
     * @type {AnimateCreatomateV1InputTemplate}
     * @memberof AnimateCreatomateV1Input
     */
    'template': AnimateCreatomateV1InputTemplate;
}
/**
 * @type AnimateCreatomateV1InputTemplate
 * @export
 */
export type AnimateCreatomateV1InputTemplate = object | string;

/**
 * 
 * @export
 * @interface AnimateCreatomateV1Request
 */
export interface AnimateCreatomateV1Request {
    /**
     * 
     * @type {AnimateCreatomateV1Input}
     * @memberof AnimateCreatomateV1Request
     */
    'input': AnimateCreatomateV1Input;
    /**
     * 
     * @type {object}
     * @memberof AnimateCreatomateV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface AnimateCreatomateV1Response
 */
export interface AnimateCreatomateV1Response {
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'kind': AnimateCreatomateV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputVideoSingle}
     * @memberof AnimateCreatomateV1Response
     */
    'output': OperationOutputVideoSingle;
    /**
     * 
     * @type {object}
     * @memberof AnimateCreatomateV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'status': AnimateCreatomateV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof AnimateCreatomateV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateCreatomateV1Response
     */
    'updatedAt': string;
}

export const AnimateCreatomateV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type AnimateCreatomateV1ResponseKindEnum = typeof AnimateCreatomateV1ResponseKindEnum[keyof typeof AnimateCreatomateV1ResponseKindEnum];
export const AnimateCreatomateV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type AnimateCreatomateV1ResponseStatusEnum = typeof AnimateCreatomateV1ResponseStatusEnum[keyof typeof AnimateCreatomateV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AnimateKling16ProV1Input
 */
export interface AnimateKling16ProV1Input {
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'negativePrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'aspectRatio'?: AnimateKling16ProV1InputAspectRatioEnum;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'startImageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'endImageId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnimateKling16ProV1Input
     */
    'promptRelevance'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Input
     */
    'duration'?: AnimateKling16ProV1InputDurationEnum;
}

export const AnimateKling16ProV1InputAspectRatioEnum = {
    _11: '1:1',
    _916: '9:16',
    _169: '16:9'
} as const;

export type AnimateKling16ProV1InputAspectRatioEnum = typeof AnimateKling16ProV1InputAspectRatioEnum[keyof typeof AnimateKling16ProV1InputAspectRatioEnum];
export const AnimateKling16ProV1InputDurationEnum = {
    _5: '5',
    _10: '10'
} as const;

export type AnimateKling16ProV1InputDurationEnum = typeof AnimateKling16ProV1InputDurationEnum[keyof typeof AnimateKling16ProV1InputDurationEnum];

/**
 * 
 * @export
 * @interface AnimateKling16ProV1Request
 */
export interface AnimateKling16ProV1Request {
    /**
     * 
     * @type {AnimateKling16ProV1Input}
     * @memberof AnimateKling16ProV1Request
     */
    'input': AnimateKling16ProV1Input;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling16ProV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface AnimateKling16ProV1Response
 */
export interface AnimateKling16ProV1Response {
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'kind': AnimateKling16ProV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputVideoSingle}
     * @memberof AnimateKling16ProV1Response
     */
    'output': OperationOutputVideoSingle;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling16ProV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'status': AnimateKling16ProV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling16ProV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling16ProV1Response
     */
    'updatedAt': string;
}

export const AnimateKling16ProV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type AnimateKling16ProV1ResponseKindEnum = typeof AnimateKling16ProV1ResponseKindEnum[keyof typeof AnimateKling16ProV1ResponseKindEnum];
export const AnimateKling16ProV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type AnimateKling16ProV1ResponseStatusEnum = typeof AnimateKling16ProV1ResponseStatusEnum[keyof typeof AnimateKling16ProV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AnimateKling21V1Input
 */
export interface AnimateKling21V1Input {
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Input
     */
    'negativePrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Input
     */
    'startImageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Input
     */
    'duration'?: AnimateKling21V1InputDurationEnum;
}

export const AnimateKling21V1InputDurationEnum = {
    _5: '5',
    _10: '10'
} as const;

export type AnimateKling21V1InputDurationEnum = typeof AnimateKling21V1InputDurationEnum[keyof typeof AnimateKling21V1InputDurationEnum];

/**
 * 
 * @export
 * @interface AnimateKling21V1Request
 */
export interface AnimateKling21V1Request {
    /**
     * 
     * @type {AnimateKling21V1Input}
     * @memberof AnimateKling21V1Request
     */
    'input': AnimateKling21V1Input;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling21V1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface AnimateKling21V1Response
 */
export interface AnimateKling21V1Response {
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'kind': AnimateKling21V1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputVideoSingle}
     * @memberof AnimateKling21V1Response
     */
    'output': OperationOutputVideoSingle;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling21V1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'status': AnimateKling21V1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof AnimateKling21V1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AnimateKling21V1Response
     */
    'updatedAt': string;
}

export const AnimateKling21V1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type AnimateKling21V1ResponseKindEnum = typeof AnimateKling21V1ResponseKindEnum[keyof typeof AnimateKling21V1ResponseKindEnum];
export const AnimateKling21V1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type AnimateKling21V1ResponseStatusEnum = typeof AnimateKling21V1ResponseStatusEnum[keyof typeof AnimateKling21V1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AttachAccessControllerParamsDto
 */
export interface AttachAccessControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AttachAccessControllerParamsDto
     */
    'parentResourceId': string;
}
/**
 * 
 * @export
 * @interface AttachAccessParamsDto
 */
export interface AttachAccessParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AttachAccessParamsDto
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof AttachAccessParamsDto
     */
    'parentResourceId': string;
}
/**
 * 
 * @export
 * @interface BalanceResultDto
 */
export interface BalanceResultDto {
    /**
     * 
     * @type {string}
     * @memberof BalanceResultDto
     */
    'balance': string;
}
/**
 * 
 * @export
 * @interface CollectionEntity
 */
export interface CollectionEntity {
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'kind': CollectionEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CollectionEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'updatedAt': string;
}

export const CollectionEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;

export type CollectionEntityKindEnum = typeof CollectionEntityKindEnum[keyof typeof CollectionEntityKindEnum];

/**
 * 
 * @export
 * @interface CompositeElement
 */
export interface CompositeElement {
    /**
     * libvips blending mode
     * @type {string}
     * @memberof CompositeElement
     */
    'blend'?: CompositeElementBlendEnum;
    /**
     * 
     * @type {string}
     * @memberof CompositeElement
     */
    'imageId': string;
    /**
     * 
     * @type {number}
     * @memberof CompositeElement
     */
    'left': number;
    /**
     * 
     * @type {number}
     * @memberof CompositeElement
     */
    'top': number;
    /**
     * 
     * @type {number}
     * @memberof CompositeElement
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof CompositeElement
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof CompositeElement
     */
    'fit': CompositeElementFitEnum;
}

export const CompositeElementBlendEnum = {
    Over: 'over',
    Screen: 'screen',
    Difference: 'difference',
    Multiply: 'multiply'
} as const;

export type CompositeElementBlendEnum = typeof CompositeElementBlendEnum[keyof typeof CompositeElementBlendEnum];
export const CompositeElementFitEnum = {
    Cover: 'cover',
    Contain: 'contain',
    Fill: 'fill',
    Inside: 'inside',
    Outside: 'outside'
} as const;

export type CompositeElementFitEnum = typeof CompositeElementFitEnum[keyof typeof CompositeElementFitEnum];

/**
 * 
 * @export
 * @interface CompositeV1Input
 */
export interface CompositeV1Input {
    /**
     * 
     * @type {number}
     * @memberof CompositeV1Input
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof CompositeV1Input
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Input
     */
    'background': string;
    /**
     * 
     * @type {Array<CompositeElement>}
     * @memberof CompositeV1Input
     */
    'elements': Array<CompositeElement>;
}
/**
 * 
 * @export
 * @interface CompositeV1Request
 */
export interface CompositeV1Request {
    /**
     * 
     * @type {CompositeV1Input}
     * @memberof CompositeV1Request
     */
    'input': CompositeV1Input;
    /**
     * 
     * @type {object}
     * @memberof CompositeV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CompositeV1Response
 */
export interface CompositeV1Response {
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'kind': CompositeV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof CompositeV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof CompositeV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'status': CompositeV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CompositeV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompositeV1Response
     */
    'updatedAt': string;
}

export const CompositeV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type CompositeV1ResponseKindEnum = typeof CompositeV1ResponseKindEnum[keyof typeof CompositeV1ResponseKindEnum];
export const CompositeV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type CompositeV1ResponseStatusEnum = typeof CompositeV1ResponseStatusEnum[keyof typeof CompositeV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ContrastV1Input
 */
export interface ContrastV1Input {
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {number}
     * @memberof ContrastV1Input
     */
    'contrast': number;
}
/**
 * 
 * @export
 * @interface ContrastV1Request
 */
export interface ContrastV1Request {
    /**
     * 
     * @type {ContrastV1Input}
     * @memberof ContrastV1Request
     */
    'input': ContrastV1Input;
    /**
     * 
     * @type {object}
     * @memberof ContrastV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ContrastV1Response
 */
export interface ContrastV1Response {
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'kind': ContrastV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof ContrastV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof ContrastV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'status': ContrastV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ContrastV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ContrastV1Response
     */
    'updatedAt': string;
}

export const ContrastV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type ContrastV1ResponseKindEnum = typeof ContrastV1ResponseKindEnum[keyof typeof ContrastV1ResponseKindEnum];
export const ContrastV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type ContrastV1ResponseStatusEnum = typeof ContrastV1ResponseStatusEnum[keyof typeof ContrastV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreateAccountParamsDto
 */
export interface CreateAccountParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountParamsDto
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionParamsDto
 */
export interface CreateCollectionParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateImageParamsDto
 */
export interface CreateImageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateImageParamsDto
     */
    'fileToken'?: string;
}
/**
 * 
 * @export
 * @interface CreatePipelineParamsDto
 */
export interface CreatePipelineParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'metadata'?: object;
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'pipelineInput'?: object;
    /**
     * 
     * @type {Array<CreatePipelineTaskDto>}
     * @memberof CreatePipelineParamsDto
     */
    'tasks': Array<CreatePipelineTaskDto>;
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'outputRef'?: object;
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'state'?: object;
}
/**
 * 
 * @export
 * @interface CreatePipelineTaskDto
 */
export interface CreatePipelineTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePipelineTaskDto
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePipelineTaskDto
     */
    'dependencies': Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof CreatePipelineTaskDto
     */
    'args': Array<object>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePipelineTaskDto
     */
    'method': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateStackParamsDto
 */
export interface CreateStackParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateStackParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateStorageRecordParamsDto
 */
export interface CreateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof CreateStorageRecordParamsDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface CreateVideoParamsDto
 */
export interface CreateVideoParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateVideoParamsDto
     */
    'fileToken'?: string;
}
/**
 * 
 * @export
 * @interface CreateWorkflowParamsDto
 */
export interface CreateWorkflowParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateWorkflowParamsDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowParamsDto
     */
    'version': string;
    /**
     * 
     * @type {object}
     * @memberof CreateWorkflowParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CropV1Input
 */
export interface CropV1Input {
    /**
     * 
     * @type {string}
     * @memberof CropV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {number}
     * @memberof CropV1Input
     */
    'left': number;
    /**
     * 
     * @type {number}
     * @memberof CropV1Input
     */
    'top': number;
    /**
     * 
     * @type {number}
     * @memberof CropV1Input
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof CropV1Input
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface CropV1Request
 */
export interface CropV1Request {
    /**
     * 
     * @type {CropV1Input}
     * @memberof CropV1Request
     */
    'input': CropV1Input;
    /**
     * 
     * @type {object}
     * @memberof CropV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CropV1Response
 */
export interface CropV1Response {
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'kind': CropV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof CropV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof CropV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'status': CropV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CropV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CropV1Response
     */
    'updatedAt': string;
}

export const CropV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type CropV1ResponseKindEnum = typeof CropV1ResponseKindEnum[keyof typeof CropV1ResponseKindEnum];
export const CropV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type CropV1ResponseStatusEnum = typeof CropV1ResponseStatusEnum[keyof typeof CropV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CutV1Input
 */
export interface CutV1Input {
    /**
     * 
     * @type {string}
     * @memberof CutV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof CutV1Input
     */
    'maskImageId': string;
}
/**
 * 
 * @export
 * @interface CutV1Request
 */
export interface CutV1Request {
    /**
     * 
     * @type {CutV1Input}
     * @memberof CutV1Request
     */
    'input': CutV1Input;
    /**
     * 
     * @type {object}
     * @memberof CutV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CutV1Response
 */
export interface CutV1Response {
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'kind': CutV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof CutV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof CutV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'status': CutV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CutV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CutV1Response
     */
    'updatedAt': string;
}

export const CutV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type CutV1ResponseKindEnum = typeof CutV1ResponseKindEnum[keyof typeof CutV1ResponseKindEnum];
export const CutV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type CutV1ResponseStatusEnum = typeof CutV1ResponseStatusEnum[keyof typeof CutV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface DeleteParamsDto
 */
export interface DeleteParamsDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteStorageParamsDto
 */
export interface DeleteStorageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteStorageParamsDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface DetachAccessControllerParamsDto
 */
export interface DetachAccessControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof DetachAccessControllerParamsDto
     */
    'parentResourceId': string;
}
/**
 * 
 * @export
 * @interface EchoV1Input
 */
export interface EchoV1Input {
    /**
     * 
     * @type {string}
     * @memberof EchoV1Input
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface EchoV1Request
 */
export interface EchoV1Request {
    /**
     * 
     * @type {EchoV1Input}
     * @memberof EchoV1Request
     */
    'input': EchoV1Input;
    /**
     * 
     * @type {object}
     * @memberof EchoV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface EchoV1Response
 */
export interface EchoV1Response {
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'kind': EchoV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputTextSingle}
     * @memberof EchoV1Response
     */
    'output': OperationOutputTextSingle;
    /**
     * 
     * @type {object}
     * @memberof EchoV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'status': EchoV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof EchoV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EchoV1Response
     */
    'updatedAt': string;
}

export const EchoV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type EchoV1ResponseKindEnum = typeof EchoV1ResponseKindEnum[keyof typeof EchoV1ResponseKindEnum];
export const EchoV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type EchoV1ResponseStatusEnum = typeof EchoV1ResponseStatusEnum[keyof typeof EchoV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface EditFluxKontextDevV1Input
 */
export interface EditFluxKontextDevV1Input {
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Input
     */
    'imageId'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditFluxKontextDevV1Input
     */
    'numberOfSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditFluxKontextDevV1Input
     */
    'guidance'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditFluxKontextDevV1Input
     */
    'seed'?: number;
}
/**
 * 
 * @export
 * @interface EditFluxKontextDevV1Request
 */
export interface EditFluxKontextDevV1Request {
    /**
     * 
     * @type {EditFluxKontextDevV1Input}
     * @memberof EditFluxKontextDevV1Request
     */
    'input': EditFluxKontextDevV1Input;
    /**
     * 
     * @type {object}
     * @memberof EditFluxKontextDevV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface EditFluxKontextDevV1Response
 */
export interface EditFluxKontextDevV1Response {
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'kind': EditFluxKontextDevV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof EditFluxKontextDevV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof EditFluxKontextDevV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'status': EditFluxKontextDevV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof EditFluxKontextDevV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EditFluxKontextDevV1Response
     */
    'updatedAt': string;
}

export const EditFluxKontextDevV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type EditFluxKontextDevV1ResponseKindEnum = typeof EditFluxKontextDevV1ResponseKindEnum[keyof typeof EditFluxKontextDevV1ResponseKindEnum];
export const EditFluxKontextDevV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type EditFluxKontextDevV1ResponseStatusEnum = typeof EditFluxKontextDevV1ResponseStatusEnum[keyof typeof EditFluxKontextDevV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GPTV1Input
 */
export interface GPTV1Input {
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'model'?: GPTV1InputModelEnum;
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GPTV1Input
     */
    'additionalMessages'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'imageId'?: string;
}

export const GPTV1InputModelEnum = {
    Gpt4o: 'gpt-4o',
    Gpt41Mini: 'gpt-4.1-mini'
} as const;

export type GPTV1InputModelEnum = typeof GPTV1InputModelEnum[keyof typeof GPTV1InputModelEnum];

/**
 * 
 * @export
 * @interface GPTV2AssistantMessageDto
 */
export interface GPTV2AssistantMessageDto {
    /**
     * The content of the assistant message.
     * @type {string}
     * @memberof GPTV2AssistantMessageDto
     */
    'content'?: string;
    /**
     * The role of the message sender.
     * @type {string}
     * @memberof GPTV2AssistantMessageDto
     */
    'role': GPTV2AssistantMessageDtoRoleEnum;
    /**
     * The name of the sender, if applicable.
     * @type {string}
     * @memberof GPTV2AssistantMessageDto
     */
    'name'?: string;
    /**
     * The refusal message, if applicable.
     * @type {string}
     * @memberof GPTV2AssistantMessageDto
     */
    'refusal'?: string;
    /**
     * The tool calls made by the assistant, if any.
     * @type {Array<GPTV2MessageToolCallDto>}
     * @memberof GPTV2AssistantMessageDto
     */
    'tool_calls'?: Array<GPTV2MessageToolCallDto>;
}

export const GPTV2AssistantMessageDtoRoleEnum = {
    Assistant: 'assistant'
} as const;

export type GPTV2AssistantMessageDtoRoleEnum = typeof GPTV2AssistantMessageDtoRoleEnum[keyof typeof GPTV2AssistantMessageDtoRoleEnum];

/**
 * 
 * @export
 * @interface GPTV2DeveloperMessageDto
 */
export interface GPTV2DeveloperMessageDto {
    /**
     * The content of the developer message.
     * @type {string}
     * @memberof GPTV2DeveloperMessageDto
     */
    'content': string;
    /**
     * The role of the message sender.
     * @type {string}
     * @memberof GPTV2DeveloperMessageDto
     */
    'role': GPTV2DeveloperMessageDtoRoleEnum;
    /**
     * The name of the sender, if applicable.
     * @type {string}
     * @memberof GPTV2DeveloperMessageDto
     */
    'name'?: string;
}

export const GPTV2DeveloperMessageDtoRoleEnum = {
    Developer: 'developer'
} as const;

export type GPTV2DeveloperMessageDtoRoleEnum = typeof GPTV2DeveloperMessageDtoRoleEnum[keyof typeof GPTV2DeveloperMessageDtoRoleEnum];

/**
 * 
 * @export
 * @interface GPTV2Input
 */
export interface GPTV2Input {
    /**
     * ID of the model to use. See OpenAI docs for model endpoint compatibility.
     * @type {string}
     * @memberof GPTV2Input
     */
    'model'?: GPTV2InputModelEnum;
    /**
     * A list of messages comprising the conversation so far. Each message must be one of: system, user, assistant, tool, or developer message DTO.
     * @type {Array<GPTV2InputMessagesInner>}
     * @memberof GPTV2Input
     */
    'messages': Array<GPTV2InputMessagesInner>;
    /**
     * 
     * @type {GPTV2InputResponseFormat}
     * @memberof GPTV2Input
     */
    'response_format'?: GPTV2InputResponseFormat;
    /**
     * This feature is in Beta. If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
     * @type {number}
     * @memberof GPTV2Input
     */
    'seed'?: number;
    /**
     * A list of tools the model may call. Currently, only functions are supported as a tool.
     * @type {Array<GPTV2ToolDto>}
     * @memberof GPTV2Input
     */
    'tools'?: Array<GPTV2ToolDto>;
    /**
     * Controls which (if any) tool is called by the model. \'none\', \'auto\', \'required\', or a specific function tool.
     * @type {GPTV2ToolChoiceDto}
     * @memberof GPTV2Input
     */
    'tool_choice'?: GPTV2ToolChoiceDto;
    /**
     * 
     * @type {GPTV2ResponseFormatTextOrObjectDto}
     * @memberof GPTV2Input
     */
    'response_format_text_or_object'?: GPTV2ResponseFormatTextOrObjectDto;
    /**
     * 
     * @type {number}
     * @memberof GPTV2Input
     */
    'max_completion_tokens'?: number;
}

export const GPTV2InputModelEnum = {
    Gpt4o: 'gpt-4o',
    O3: 'o3',
    O3Mini: 'o3-mini',
    Gpt41: 'gpt-4.1',
    Gpt41Mini: 'gpt-4.1-mini',
    Gpt41Nano: 'gpt-4.1-nano'
} as const;

export type GPTV2InputModelEnum = typeof GPTV2InputModelEnum[keyof typeof GPTV2InputModelEnum];

/**
 * @type GPTV2InputMessagesInner
 * @export
 */
export type GPTV2InputMessagesInner = GPTV2AssistantMessageDto | GPTV2DeveloperMessageDto | GPTV2SystemMessageDto | GPTV2ToolMessageDto | GPTV2UserMessageDto;

/**
 * @type GPTV2InputResponseFormat
 * The response format for the model output. See OpenAI docs for details.
 * @export
 */
export type GPTV2InputResponseFormat = GPTV2ResponseFormatJsonSchemaDto | GPTV2ResponseFormatTextOrObjectDto;

/**
 * 
 * @export
 * @interface GPTV2MessageToolCallDto
 */
export interface GPTV2MessageToolCallDto {
    /**
     * 
     * @type {string}
     * @memberof GPTV2MessageToolCallDto
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof GPTV2MessageToolCallDto
     */
    'function': object;
    /**
     * 
     * @type {string}
     * @memberof GPTV2MessageToolCallDto
     */
    'type': GPTV2MessageToolCallDtoTypeEnum;
}

export const GPTV2MessageToolCallDtoTypeEnum = {
    Function: 'function'
} as const;

export type GPTV2MessageToolCallDtoTypeEnum = typeof GPTV2MessageToolCallDtoTypeEnum[keyof typeof GPTV2MessageToolCallDtoTypeEnum];

/**
 * 
 * @export
 * @interface GPTV2ResponseFormatJsonSchemaDetailsDto
 */
export interface GPTV2ResponseFormatJsonSchemaDetailsDto {
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof GPTV2ResponseFormatJsonSchemaDetailsDto
     */
    'name': string;
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     * @type {string}
     * @memberof GPTV2ResponseFormatJsonSchemaDetailsDto
     */
    'description'?: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     * @type {object}
     * @memberof GPTV2ResponseFormatJsonSchemaDetailsDto
     */
    'schema'?: object;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`.
     * @type {boolean}
     * @memberof GPTV2ResponseFormatJsonSchemaDetailsDto
     */
    'strict'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GPTV2ResponseFormatJsonSchemaDto
 */
export interface GPTV2ResponseFormatJsonSchemaDto {
    /**
     * The type of response format being defined: json_schema.
     * @type {string}
     * @memberof GPTV2ResponseFormatJsonSchemaDto
     */
    'type': GPTV2ResponseFormatJsonSchemaDtoTypeEnum;
    /**
     * The JSON schema definition for the response format. Required for type json_schema.
     * @type {GPTV2ResponseFormatJsonSchemaDetailsDto}
     * @memberof GPTV2ResponseFormatJsonSchemaDto
     */
    'json_schema': GPTV2ResponseFormatJsonSchemaDetailsDto;
}

export const GPTV2ResponseFormatJsonSchemaDtoTypeEnum = {
    JsonSchema: 'json_schema'
} as const;

export type GPTV2ResponseFormatJsonSchemaDtoTypeEnum = typeof GPTV2ResponseFormatJsonSchemaDtoTypeEnum[keyof typeof GPTV2ResponseFormatJsonSchemaDtoTypeEnum];

/**
 * 
 * @export
 * @interface GPTV2ResponseFormatTextOrObjectDto
 */
export interface GPTV2ResponseFormatTextOrObjectDto {
    /**
     * The type of response format being defined: \'text\' or \'json_object\'.
     * @type {object}
     * @memberof GPTV2ResponseFormatTextOrObjectDto
     */
    'type': GPTV2ResponseFormatTextOrObjectDtoTypeEnum;
}

export const GPTV2ResponseFormatTextOrObjectDtoTypeEnum = {
    Text: 'text',
    JsonObject: 'json_object'
} as const;

export type GPTV2ResponseFormatTextOrObjectDtoTypeEnum = typeof GPTV2ResponseFormatTextOrObjectDtoTypeEnum[keyof typeof GPTV2ResponseFormatTextOrObjectDtoTypeEnum];

/**
 * 
 * @export
 * @interface GPTV2SystemMessageDto
 */
export interface GPTV2SystemMessageDto {
    /**
     * The content of the system message.
     * @type {string}
     * @memberof GPTV2SystemMessageDto
     */
    'content': string;
    /**
     * The role of the message sender.
     * @type {string}
     * @memberof GPTV2SystemMessageDto
     */
    'role': GPTV2SystemMessageDtoRoleEnum;
    /**
     * The name of the sender, if applicable.
     * @type {string}
     * @memberof GPTV2SystemMessageDto
     */
    'name'?: string;
}

export const GPTV2SystemMessageDtoRoleEnum = {
    System: 'system'
} as const;

export type GPTV2SystemMessageDtoRoleEnum = typeof GPTV2SystemMessageDtoRoleEnum[keyof typeof GPTV2SystemMessageDtoRoleEnum];

/**
 * 
 * @export
 * @interface GPTV2ToolChoiceDto
 */
export interface GPTV2ToolChoiceDto {
    /**
     * Controls which (if any) tool is called by the model. \'none\', \'auto\', \'required\', or a specific function tool.
     * @type {object}
     * @memberof GPTV2ToolChoiceDto
     */
    'type': GPTV2ToolChoiceDtoTypeEnum;
    /**
     * The function to call, if type is `function`.
     * @type {GPTV2ToolChoiceFunctionDto}
     * @memberof GPTV2ToolChoiceDto
     */
    'function'?: GPTV2ToolChoiceFunctionDto;
}

export const GPTV2ToolChoiceDtoTypeEnum = {
    None: 'none',
    Auto: 'auto',
    Required: 'required',
    Function: 'function'
} as const;

export type GPTV2ToolChoiceDtoTypeEnum = typeof GPTV2ToolChoiceDtoTypeEnum[keyof typeof GPTV2ToolChoiceDtoTypeEnum];

/**
 * 
 * @export
 * @interface GPTV2ToolChoiceFunctionDto
 */
export interface GPTV2ToolChoiceFunctionDto {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof GPTV2ToolChoiceFunctionDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GPTV2ToolDto
 */
export interface GPTV2ToolDto {
    /**
     * The function definition for the tool. Currently, only functions are supported.
     * @type {GPTV2ToolFunctionDto}
     * @memberof GPTV2ToolDto
     */
    'function': GPTV2ToolFunctionDto;
    /**
     * The type of the tool. Currently, only \'function\' is supported.
     * @type {string}
     * @memberof GPTV2ToolDto
     */
    'type': GPTV2ToolDtoTypeEnum;
}

export const GPTV2ToolDtoTypeEnum = {
    Function: 'function'
} as const;

export type GPTV2ToolDtoTypeEnum = typeof GPTV2ToolDtoTypeEnum[keyof typeof GPTV2ToolDtoTypeEnum];

/**
 * 
 * @export
 * @interface GPTV2ToolFunctionDto
 */
export interface GPTV2ToolFunctionDto {
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof GPTV2ToolFunctionDto
     */
    'name': string;
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     * @type {string}
     * @memberof GPTV2ToolFunctionDto
     */
    'description'?: string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object.
     * @type {object}
     * @memberof GPTV2ToolFunctionDto
     */
    'parameters'?: object;
    /**
     * Whether to enable strict schema adherence when generating the function call.
     * @type {boolean}
     * @memberof GPTV2ToolFunctionDto
     */
    'strict'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GPTV2ToolMessageDto
 */
export interface GPTV2ToolMessageDto {
    /**
     * The content of the tool message.
     * @type {string}
     * @memberof GPTV2ToolMessageDto
     */
    'content': string;
    /**
     * The role of the message sender.
     * @type {string}
     * @memberof GPTV2ToolMessageDto
     */
    'role': GPTV2ToolMessageDtoRoleEnum;
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof GPTV2ToolMessageDto
     */
    'tool_call_id': string;
}

export const GPTV2ToolMessageDtoRoleEnum = {
    Tool: 'tool'
} as const;

export type GPTV2ToolMessageDtoRoleEnum = typeof GPTV2ToolMessageDtoRoleEnum[keyof typeof GPTV2ToolMessageDtoRoleEnum];

/**
 * 
 * @export
 * @interface GPTV2UserMessageDto
 */
export interface GPTV2UserMessageDto {
    /**
     * The content of the user message.
     * @type {string}
     * @memberof GPTV2UserMessageDto
     */
    'content': string;
    /**
     * The role of the message sender.
     * @type {string}
     * @memberof GPTV2UserMessageDto
     */
    'role': GPTV2UserMessageDtoRoleEnum;
    /**
     * The name of the sender, if applicable.
     * @type {string}
     * @memberof GPTV2UserMessageDto
     */
    'name'?: string;
}

export const GPTV2UserMessageDtoRoleEnum = {
    User: 'user'
} as const;

export type GPTV2UserMessageDtoRoleEnum = typeof GPTV2UserMessageDtoRoleEnum[keyof typeof GPTV2UserMessageDtoRoleEnum];

/**
 * 
 * @export
 * @interface GetAccountParamsDto
 */
export interface GetAccountParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetAccountParamsDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccountParamsDto
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface GetBalanceParamsDto
 */
export interface GetBalanceParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetBalanceParamsDto
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface GetCollectionParamsDto
 */
export interface GetCollectionParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetCollectionParamsDto
     */
    'collectionId': string;
}
/**
 * 
 * @export
 * @interface GetGroupParamsDto
 */
export interface GetGroupParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetGroupParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetImageParamsDto
 */
export interface GetImageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetImageParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetImageRepresentationParamsDto
 */
export interface GetImageRepresentationParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetImageRepresentationParamsDto
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof GetImageRepresentationParamsDto
     */
    'type': GetImageRepresentationParamsDtoTypeEnum;
}

export const GetImageRepresentationParamsDtoTypeEnum = {
    SamV1: 'sam.v1'
} as const;

export type GetImageRepresentationParamsDtoTypeEnum = typeof GetImageRepresentationParamsDtoTypeEnum[keyof typeof GetImageRepresentationParamsDtoTypeEnum];

/**
 * 
 * @export
 * @interface GetOperationParamsDto
 */
export interface GetOperationParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetOperationParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetOperationsParamsDto
 */
export interface GetOperationsParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetOperationsParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetPoseParamsDto
 */
export interface GetPoseParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetPoseParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetStackParamsDto
 */
export interface GetStackParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetStackParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetStorageRecordParamsDto
 */
export interface GetStorageRecordParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetStorageRecordParamsDto
     */
    'keys': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUrlsForImagesParamsDto
 */
export interface GetUrlsForImagesParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUrlsForImagesParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetVideoParamsDto
 */
export interface GetVideoParamsDto {
    /**
     * 
     * @type {string}
     * @memberof GetVideoParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetVideosParamsDto
 */
export interface GetVideosParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetVideosParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GiseleVtonV1Input
 */
export interface GiseleVtonV1Input {
    /**
     * 
     * @type {string}
     * @memberof GiseleVtonV1Input
     */
    'category': GiseleVtonV1InputCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof GiseleVtonV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof GiseleVtonV1Input
     */
    'productDescription': string;
    /**
     * 
     * @type {string}
     * @memberof GiseleVtonV1Input
     */
    'productImageId': string;
    /**
     * 
     * @type {number}
     * @memberof GiseleVtonV1Input
     */
    'seed': number;
}

export const GiseleVtonV1InputCategoryEnum = {
    Dresses: 'dresses',
    LowerBody: 'lower_body',
    UpperBody: 'upper_body'
} as const;

export type GiseleVtonV1InputCategoryEnum = typeof GiseleVtonV1InputCategoryEnum[keyof typeof GiseleVtonV1InputCategoryEnum];

/**
 * 
 * @export
 * @interface GptV1Request
 */
export interface GptV1Request {
    /**
     * 
     * @type {GPTV1Input}
     * @memberof GptV1Request
     */
    'input': GPTV1Input;
    /**
     * 
     * @type {object}
     * @memberof GptV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GptV1Response
 */
export interface GptV1Response {
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'kind': GptV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof GptV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof GptV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'status': GptV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof GptV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GptV1Response
     */
    'updatedAt': string;
}

export const GptV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type GptV1ResponseKindEnum = typeof GptV1ResponseKindEnum[keyof typeof GptV1ResponseKindEnum];
export const GptV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type GptV1ResponseStatusEnum = typeof GptV1ResponseStatusEnum[keyof typeof GptV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GptV2Request
 */
export interface GptV2Request {
    /**
     * 
     * @type {GPTV2Input}
     * @memberof GptV2Request
     */
    'input': GPTV2Input;
    /**
     * 
     * @type {object}
     * @memberof GptV2Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GptV2Response
 */
export interface GptV2Response {
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'kind': GptV2ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof GptV2Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof GptV2Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'status': GptV2ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof GptV2Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GptV2Response
     */
    'updatedAt': string;
}

export const GptV2ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type GptV2ResponseKindEnum = typeof GptV2ResponseKindEnum[keyof typeof GptV2ResponseKindEnum];
export const GptV2ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type GptV2ResponseStatusEnum = typeof GptV2ResponseStatusEnum[keyof typeof GptV2ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GrantAccessControllerParams
 */
export interface GrantAccessControllerParams {
    /**
     * 
     * @type {string}
     * @memberof GrantAccessControllerParams
     */
    'principalType': GrantAccessControllerParamsPrincipalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GrantAccessControllerParams
     */
    'principalId': string;
    /**
     * 
     * @type {string}
     * @memberof GrantAccessControllerParams
     */
    'access': string;
}

export const GrantAccessControllerParamsPrincipalTypeEnum = {
    Account: 'account',
    Group: 'group'
} as const;

export type GrantAccessControllerParamsPrincipalTypeEnum = typeof GrantAccessControllerParamsPrincipalTypeEnum[keyof typeof GrantAccessControllerParamsPrincipalTypeEnum];

/**
 * 
 * @export
 * @interface GroupEntity
 */
export interface GroupEntity {
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface HauteLindaV1Request
 */
export interface HauteLindaV1Request {
    /**
     * 
     * @type {LindaHauteV1Input}
     * @memberof HauteLindaV1Request
     */
    'input': LindaHauteV1Input;
    /**
     * 
     * @type {object}
     * @memberof HauteLindaV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface HauteLindaV1Response
 */
export interface HauteLindaV1Response {
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'kind': HauteLindaV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageMultiple}
     * @memberof HauteLindaV1Response
     */
    'output': OperationOutputImageMultiple;
    /**
     * 
     * @type {object}
     * @memberof HauteLindaV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'status': HauteLindaV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof HauteLindaV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof HauteLindaV1Response
     */
    'updatedAt': string;
}

export const HauteLindaV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type HauteLindaV1ResponseKindEnum = typeof HauteLindaV1ResponseKindEnum[keyof typeof HauteLindaV1ResponseKindEnum];
export const HauteLindaV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type HauteLindaV1ResponseStatusEnum = typeof HauteLindaV1ResponseStatusEnum[keyof typeof HauteLindaV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface HauteNaomiV1Request
 */
export interface HauteNaomiV1Request {
    /**
     * 
     * @type {NaomiHauteV1Input}
     * @memberof HauteNaomiV1Request
     */
    'input': NaomiHauteV1Input;
    /**
     * 
     * @type {object}
     * @memberof HauteNaomiV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface HauteNaomiV1Response
 */
export interface HauteNaomiV1Response {
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'kind': HauteNaomiV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof HauteNaomiV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof HauteNaomiV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'status': HauteNaomiV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof HauteNaomiV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof HauteNaomiV1Response
     */
    'updatedAt': string;
}

export const HauteNaomiV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type HauteNaomiV1ResponseKindEnum = typeof HauteNaomiV1ResponseKindEnum[keyof typeof HauteNaomiV1ResponseKindEnum];
export const HauteNaomiV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type HauteNaomiV1ResponseStatusEnum = typeof HauteNaomiV1ResponseStatusEnum[keyof typeof HauteNaomiV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImageEntity
 */
export interface ImageEntity {
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'kind': ImageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ImageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'format': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'url': string;
}

export const ImageEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;

export type ImageEntityKindEnum = typeof ImageEntityKindEnum[keyof typeof ImageEntityKindEnum];

/**
 * 
 * @export
 * @interface ImageRepresentationResponseDto
 */
export interface ImageRepresentationResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImageUrlResponseDto
 */
export interface ImageUrlResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ImageUrlResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrlResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImagineKateV1Request
 */
export interface ImagineKateV1Request {
    /**
     * 
     * @type {KateImagineV1Input}
     * @memberof ImagineKateV1Request
     */
    'input': KateImagineV1Input;
    /**
     * 
     * @type {object}
     * @memberof ImagineKateV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ImagineKateV1Response
 */
export interface ImagineKateV1Response {
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'kind': ImagineKateV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof ImagineKateV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof ImagineKateV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'status': ImagineKateV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ImagineKateV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImagineKateV1Response
     */
    'updatedAt': string;
}

export const ImagineKateV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type ImagineKateV1ResponseKindEnum = typeof ImagineKateV1ResponseKindEnum[keyof typeof ImagineKateV1ResponseKindEnum];
export const ImagineKateV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type ImagineKateV1ResponseStatusEnum = typeof ImagineKateV1ResponseStatusEnum[keyof typeof ImagineKateV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface InitializeImageUploadResultDto
 */
export interface InitializeImageUploadResultDto {
    /**
     * 
     * @type {string}
     * @memberof InitializeImageUploadResultDto
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface InpaintKateV1Request
 */
export interface InpaintKateV1Request {
    /**
     * 
     * @type {KateInpaintV1Input}
     * @memberof InpaintKateV1Request
     */
    'input': KateInpaintV1Input;
    /**
     * 
     * @type {object}
     * @memberof InpaintKateV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InpaintKateV1Response
 */
export interface InpaintKateV1Response {
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'kind': InpaintKateV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof InpaintKateV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof InpaintKateV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'status': InpaintKateV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof InpaintKateV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InpaintKateV1Response
     */
    'updatedAt': string;
}

export const InpaintKateV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type InpaintKateV1ResponseKindEnum = typeof InpaintKateV1ResponseKindEnum[keyof typeof InpaintKateV1ResponseKindEnum];
export const InpaintKateV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type InpaintKateV1ResponseStatusEnum = typeof InpaintKateV1ResponseStatusEnum[keyof typeof InpaintKateV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface KateImagineV1Input
 */
export interface KateImagineV1Input {
    /**
     * 
     * @type {string}
     * @memberof KateImagineV1Input
     */
    'aspectRatio': KateImagineV1InputAspectRatioEnum;
    /**
     * 
     * @type {string}
     * @memberof KateImagineV1Input
     */
    'seed': string;
    /**
     * 
     * @type {string}
     * @memberof KateImagineV1Input
     */
    'prompt': string;
}

export const KateImagineV1InputAspectRatioEnum = {
    _11: '1:1',
    _97: '9:7',
    _79: '7:9',
    _1913: '19:13',
    _1319: '13:19',
    _74: '7:4',
    _47: '4:7'
} as const;

export type KateImagineV1InputAspectRatioEnum = typeof KateImagineV1InputAspectRatioEnum[keyof typeof KateImagineV1InputAspectRatioEnum];

/**
 * 
 * @export
 * @interface KateInpaintV1Input
 */
export interface KateInpaintV1Input {
    /**
     * 
     * @type {string}
     * @memberof KateInpaintV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof KateInpaintV1Input
     */
    'maskImageId'?: string;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'maskSpread'?: number;
    /**
     * 
     * @type {string}
     * @memberof KateInpaintV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'strength': number;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'numInferenceSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof KateInpaintV1Input
     */
    'guidanceScale'?: number;
    /**
     * 
     * @type {string}
     * @memberof KateInpaintV1Input
     */
    'branch'?: KateInpaintV1InputBranchEnum;
}

export const KateInpaintV1InputBranchEnum = {
    Stable: 'stable',
    Nightly: 'nightly'
} as const;

export type KateInpaintV1InputBranchEnum = typeof KateInpaintV1InputBranchEnum[keyof typeof KateInpaintV1InputBranchEnum];

/**
 * 
 * @export
 * @interface LindaHauteV1Input
 */
export interface LindaHauteV1Input {
    /**
     * 
     * @type {string}
     * @memberof LindaHauteV1Input
     */
    'aspectRatio': LindaHauteV1InputAspectRatioEnum;
    /**
     * 
     * @type {string}
     * @memberof LindaHauteV1Input
     */
    'productImageId': string;
    /**
     * 
     * @type {string}
     * @memberof LindaHauteV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {number}
     * @memberof LindaHauteV1Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof LindaHauteV1Input
     */
    'imageWeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof LindaHauteV1Input
     */
    'negativePrompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof LindaHauteV1Input
     */
    'inferenceSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof LindaHauteV1Input
     */
    'guidanceScale'?: number;
    /**
     * 
     * @type {number}
     * @memberof LindaHauteV1Input
     */
    'strength'?: number;
}

export const LindaHauteV1InputAspectRatioEnum = {
    _11: '1:1',
    _97: '9:7',
    _79: '7:9',
    _1913: '19:13',
    _1319: '13:19',
    _74: '7:4',
    _47: '4:7',
    _125: '12:5',
    _512: '5:12'
} as const;

export type LindaHauteV1InputAspectRatioEnum = typeof LindaHauteV1InputAspectRatioEnum[keyof typeof LindaHauteV1InputAspectRatioEnum];

/**
 * 
 * @export
 * @interface ListAccessControllerAttachmentsDto
 */
export interface ListAccessControllerAttachmentsDto {
    /**
     * 
     * @type {string}
     * @memberof ListAccessControllerAttachmentsDto
     */
    'parentResourceId': string;
}
/**
 * 
 * @export
 * @interface ListAccessControllerDto
 */
export interface ListAccessControllerDto {
    /**
     * 
     * @type {Array<ListAccessControllerAttachmentsDto>}
     * @memberof ListAccessControllerDto
     */
    'attachments': Array<ListAccessControllerAttachmentsDto>;
    /**
     * 
     * @type {Array<ListAccessControllerGrantsDto>}
     * @memberof ListAccessControllerDto
     */
    'grants': Array<ListAccessControllerGrantsDto>;
}
/**
 * 
 * @export
 * @interface ListAccessControllerGrantsDto
 */
export interface ListAccessControllerGrantsDto {
    /**
     * 
     * @type {string}
     * @memberof ListAccessControllerGrantsDto
     */
    'principalId': string;
    /**
     * 
     * @type {string}
     * @memberof ListAccessControllerGrantsDto
     */
    'principalType': string;
    /**
     * 
     * @type {string}
     * @memberof ListAccessControllerGrantsDto
     */
    'access': ListAccessControllerGrantsDtoAccessEnum;
}

export const ListAccessControllerGrantsDtoAccessEnum = {
    Owner: 'owner',
    Maintainer: 'maintainer',
    Writer: 'writer',
    Reader: 'reader',
    Member: 'member',
    CanAssignMembers: 'can_assign_members',
    CanAssignMaintainers: 'can_assign_maintainers',
    CanAssignOwners: 'can_assign_owners',
    CanView: 'can_view',
    CanWrite: 'can_write',
    CanEdit: 'can_edit',
    CanDelete: 'can_delete',
    CanChangeAccess: 'can_change_access',
    CanAddItems: 'can_add_items',
    CanRemoveItems: 'can_remove_items',
    CanList: 'can_list',
    Parent: 'parent'
} as const;

export type ListAccessControllerGrantsDtoAccessEnum = typeof ListAccessControllerGrantsDtoAccessEnum[keyof typeof ListAccessControllerGrantsDtoAccessEnum];

/**
 * 
 * @export
 * @interface ListAccountsDto
 */
export interface ListAccountsDto {
    /**
     * 
     * @type {Array<AccountEntity>}
     * @memberof ListAccountsDto
     */
    'data': Array<AccountEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListAccountsDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListAccountsDtoPageInfo
 */
export interface ListAccountsDtoPageInfo {
    /**
     * 
     * @type {string}
     * @memberof ListAccountsDtoPageInfo
     */
    'nextCursor': string;
}
/**
 * 
 * @export
 * @interface ListAccountsParamsDto
 */
export interface ListAccountsParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListAccountsParamsDto
     */
    'orderBy'?: ListAccountsParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListAccountsParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListAccountsParamsDto
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListAccountsParamsDto
     */
    'aliases'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListAccountsParamsDto
     */
    'cursor'?: string;
}

export const ListAccountsParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC'
} as const;

export type ListAccountsParamsDtoOrderByEnum = typeof ListAccountsParamsDtoOrderByEnum[keyof typeof ListAccountsParamsDtoOrderByEnum];

/**
 * 
 * @export
 * @interface ListCollectionItemsDto
 */
export interface ListCollectionItemsDto {
    /**
     * 
     * @type {Array<ResourceEntity>}
     * @memberof ListCollectionItemsDto
     */
    'data': Array<ResourceEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListCollectionItemsDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionItemsParamsDto
 */
export interface ListCollectionItemsParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListCollectionItemsParamsDto
     */
    'collectionId': string;
    /**
     * 
     * @type {string}
     * @memberof ListCollectionItemsParamsDto
     */
    'orderBy'?: ListCollectionItemsParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListCollectionItemsParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListCollectionItemsParamsDto
     */
    'kind'?: ListCollectionItemsParamsDtoKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ListCollectionItemsParamsDto
     */
    'cursor'?: string;
}

export const ListCollectionItemsParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;

export type ListCollectionItemsParamsDtoOrderByEnum = typeof ListCollectionItemsParamsDtoOrderByEnum[keyof typeof ListCollectionItemsParamsDtoOrderByEnum];
export const ListCollectionItemsParamsDtoKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;

export type ListCollectionItemsParamsDtoKindEnum = typeof ListCollectionItemsParamsDtoKindEnum[keyof typeof ListCollectionItemsParamsDtoKindEnum];

/**
 * 
 * @export
 * @interface ListCollectionsDto
 */
export interface ListCollectionsDto {
    /**
     * 
     * @type {Array<CollectionEntity>}
     * @memberof ListCollectionsDto
     */
    'data': Array<CollectionEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListCollectionsDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionsParamsDto
 */
export interface ListCollectionsParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListCollectionsParamsDto
     */
    'orderBy'?: ListCollectionsParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListCollectionsParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListCollectionsParamsDto
     */
    'cursor'?: string;
}

export const ListCollectionsParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;

export type ListCollectionsParamsDtoOrderByEnum = typeof ListCollectionsParamsDtoOrderByEnum[keyof typeof ListCollectionsParamsDtoOrderByEnum];

/**
 * 
 * @export
 * @interface ListOperationsDto
 */
export interface ListOperationsDto {
    /**
     * 
     * @type {Array<OperationEntity>}
     * @memberof ListOperationsDto
     */
    'data': Array<OperationEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListOperationsDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListOperationsParamsDto
 */
export interface ListOperationsParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListOperationsParamsDto
     */
    'orderBy'?: ListOperationsParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListOperationsParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListOperationsParamsDto
     */
    'cursor'?: string;
}

export const ListOperationsParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;

export type ListOperationsParamsDtoOrderByEnum = typeof ListOperationsParamsDtoOrderByEnum[keyof typeof ListOperationsParamsDtoOrderByEnum];

/**
 * 
 * @export
 * @interface ListPipelinesDto
 */
export interface ListPipelinesDto {
    /**
     * 
     * @type {Array<PipelinePreviewDto>}
     * @memberof ListPipelinesDto
     */
    'data': Array<PipelinePreviewDto>;
    /**
     * 
     * @type {ListPipelinesDtoPageInfo}
     * @memberof ListPipelinesDto
     */
    'pageInfo': ListPipelinesDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListPipelinesDtoPageInfo
 */
export interface ListPipelinesDtoPageInfo {
    /**
     * 
     * @type {string}
     * @memberof ListPipelinesDtoPageInfo
     */
    'nextCursor'?: string;
}
/**
 * 
 * @export
 * @interface ListPosesDto
 */
export interface ListPosesDto {
    /**
     * 
     * @type {Array<PoseEntity>}
     * @memberof ListPosesDto
     */
    'data': Array<PoseEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListPosesDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListPosesParamsDto
 */
export interface ListPosesParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListPosesParamsDto
     */
    'orderBy'?: ListPosesParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListPosesParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListPosesParamsDto
     */
    'cursor'?: string;
}

export const ListPosesParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC'
} as const;

export type ListPosesParamsDtoOrderByEnum = typeof ListPosesParamsDtoOrderByEnum[keyof typeof ListPosesParamsDtoOrderByEnum];

/**
 * 
 * @export
 * @interface ListStacksDto
 */
export interface ListStacksDto {
    /**
     * 
     * @type {Array<StackEntity>}
     * @memberof ListStacksDto
     */
    'data': Array<StackEntity>;
    /**
     * 
     * @type {ListAccountsDtoPageInfo}
     * @memberof ListStacksDto
     */
    'pageInfo': ListAccountsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListStacksParamsDto
 */
export interface ListStacksParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ListStacksParamsDto
     */
    'orderBy'?: ListStacksParamsDtoOrderByEnum;
    /**
     * 
     * @type {number}
     * @memberof ListStacksParamsDto
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListStacksParamsDto
     */
    'cursor'?: string;
}

export const ListStacksParamsDtoOrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;

export type ListStacksParamsDtoOrderByEnum = typeof ListStacksParamsDtoOrderByEnum[keyof typeof ListStacksParamsDtoOrderByEnum];

/**
 * 
 * @export
 * @interface ListWorkflowsDto
 */
export interface ListWorkflowsDto {
    /**
     * 
     * @type {Array<WorkflowDto>}
     * @memberof ListWorkflowsDto
     */
    'data': Array<WorkflowDto>;
    /**
     * 
     * @type {ListPipelinesDtoPageInfo}
     * @memberof ListWorkflowsDto
     */
    'pageInfo': ListPipelinesDtoPageInfo;
}
/**
 * 
 * @export
 * @interface MathV1Input
 */
export interface MathV1Input {
    /**
     * Mathematical expression or JSON object with expressions to evaluate using mathjs
     * @type {string}
     * @memberof MathV1Input
     */
    'code': string;
    /**
     * Input data for the mathematical expression
     * @type {object}
     * @memberof MathV1Input
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface MathV1Request
 */
export interface MathV1Request {
    /**
     * 
     * @type {MathV1Input}
     * @memberof MathV1Request
     */
    'input': MathV1Input;
    /**
     * 
     * @type {object}
     * @memberof MathV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface MathV1Response
 */
export interface MathV1Response {
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'kind': MathV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof MathV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof MathV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'status': MathV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof MathV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MathV1Response
     */
    'updatedAt': string;
}

export const MathV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type MathV1ResponseKindEnum = typeof MathV1ResponseKindEnum[keyof typeof MathV1ResponseKindEnum];
export const MathV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type MathV1ResponseStatusEnum = typeof MathV1ResponseStatusEnum[keyof typeof MathV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ModifyAccessParamsDto
 */
export interface ModifyAccessParamsDto {
    /**
     * 
     * @type {string}
     * @memberof ModifyAccessParamsDto
     */
    'principalType': ModifyAccessParamsDtoPrincipalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModifyAccessParamsDto
     */
    'principalId': string;
    /**
     * 
     * @type {string}
     * @memberof ModifyAccessParamsDto
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ModifyAccessParamsDto
     */
    'access': string;
}

export const ModifyAccessParamsDtoPrincipalTypeEnum = {
    Account: 'account',
    Group: 'group'
} as const;

export type ModifyAccessParamsDtoPrincipalTypeEnum = typeof ModifyAccessParamsDtoPrincipalTypeEnum[keyof typeof ModifyAccessParamsDtoPrincipalTypeEnum];

/**
 * 
 * @export
 * @interface NaomiHauteV1Input
 */
export interface NaomiHauteV1Input {
    /**
     * The category of the second garment
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'secondaryCategory'?: string;
    /**
     * The image of the second garment
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'secondaryGarmentImageId'?: string;
    /**
     * UNSTABLE
     * @type {Array<string>}
     * @memberof NaomiHauteV1Input
     */
    'loraIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'garmentImageId': string;
    /**
     * 
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'poseId': string;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'textGuidanceScale'?: number;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'imageGuidanceScale'?: number;
    /**
     * 
     * @type {number}
     * @memberof NaomiHauteV1Input
     */
    'numInferenceSteps'?: number;
    /**
     * 
     * @type {string}
     * @memberof NaomiHauteV1Input
     */
    'mode'?: NaomiHauteV1InputModeEnum;
}

export const NaomiHauteV1InputModeEnum = {
    ApparelToModel: 'apparel_to_model',
    ModelToModel: 'model_to_model'
} as const;

export type NaomiHauteV1InputModeEnum = typeof NaomiHauteV1InputModeEnum[keyof typeof NaomiHauteV1InputModeEnum];

/**
 * 
 * @export
 * @interface NegateImageV1Input
 */
export interface NegateImageV1Input {
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface NegateImageV1Request
 */
export interface NegateImageV1Request {
    /**
     * 
     * @type {NegateImageV1Input}
     * @memberof NegateImageV1Request
     */
    'input': NegateImageV1Input;
    /**
     * 
     * @type {object}
     * @memberof NegateImageV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface NegateImageV1Response
 */
export interface NegateImageV1Response {
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'kind': NegateImageV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof NegateImageV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof NegateImageV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'status': NegateImageV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof NegateImageV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NegateImageV1Response
     */
    'updatedAt': string;
}

export const NegateImageV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type NegateImageV1ResponseKindEnum = typeof NegateImageV1ResponseKindEnum[keyof typeof NegateImageV1ResponseKindEnum];
export const NegateImageV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type NegateImageV1ResponseStatusEnum = typeof NegateImageV1ResponseStatusEnum[keyof typeof NegateImageV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface NoiseV1Input
 */
export interface NoiseV1Input {
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {number}
     * @memberof NoiseV1Input
     */
    'mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoiseV1Input
     */
    'sigma'?: number;
}
/**
 * 
 * @export
 * @interface NoiseV1Request
 */
export interface NoiseV1Request {
    /**
     * 
     * @type {NoiseV1Input}
     * @memberof NoiseV1Request
     */
    'input': NoiseV1Input;
    /**
     * 
     * @type {object}
     * @memberof NoiseV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface NoiseV1Response
 */
export interface NoiseV1Response {
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'kind': NoiseV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof NoiseV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof NoiseV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'status': NoiseV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof NoiseV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NoiseV1Response
     */
    'updatedAt': string;
}

export const NoiseV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type NoiseV1ResponseKindEnum = typeof NoiseV1ResponseKindEnum[keyof typeof NoiseV1ResponseKindEnum];
export const NoiseV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type NoiseV1ResponseStatusEnum = typeof NoiseV1ResponseStatusEnum[keyof typeof NoiseV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ObjectDetectionV1Input
 */
export interface ObjectDetectionV1Input {
    /**
     * 
     * @type {Array<string>}
     * @memberof ObjectDetectionV1Input
     */
    'labels': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface ObjectDetectionV1Request
 */
export interface ObjectDetectionV1Request {
    /**
     * 
     * @type {ObjectDetectionV1Input}
     * @memberof ObjectDetectionV1Request
     */
    'input': ObjectDetectionV1Input;
    /**
     * 
     * @type {object}
     * @memberof ObjectDetectionV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ObjectDetectionV1Response
 */
export interface ObjectDetectionV1Response {
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'kind': ObjectDetectionV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof ObjectDetectionV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof ObjectDetectionV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'status': ObjectDetectionV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ObjectDetectionV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Response
     */
    'updatedAt': string;
}

export const ObjectDetectionV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type ObjectDetectionV1ResponseKindEnum = typeof ObjectDetectionV1ResponseKindEnum[keyof typeof ObjectDetectionV1ResponseKindEnum];
export const ObjectDetectionV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type ObjectDetectionV1ResponseStatusEnum = typeof ObjectDetectionV1ResponseStatusEnum[keyof typeof ObjectDetectionV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface OneCompilerV1Input
 */
export interface OneCompilerV1Input {
    /**
     * 
     * @type {string}
     * @memberof OneCompilerV1Input
     */
    'code': string;
    /**
     * 
     * @type {object}
     * @memberof OneCompilerV1Input
     */
    'input'?: object;
    /**
     * 
     * @type {string}
     * @memberof OneCompilerV1Input
     */
    'language'?: OneCompilerV1InputLanguageEnum;
    /**
     * 
     * @type {Array<SupportFile>}
     * @memberof OneCompilerV1Input
     */
    'supportFiles'?: Array<SupportFile>;
}

export const OneCompilerV1InputLanguageEnum = {
    Typescript: 'typescript',
    Python: 'python'
} as const;

export type OneCompilerV1InputLanguageEnum = typeof OneCompilerV1InputLanguageEnum[keyof typeof OneCompilerV1InputLanguageEnum];

/**
 * 
 * @export
 * @interface OnecompilerV1Request
 */
export interface OnecompilerV1Request {
    /**
     * 
     * @type {OneCompilerV1Input}
     * @memberof OnecompilerV1Request
     */
    'input': OneCompilerV1Input;
    /**
     * 
     * @type {object}
     * @memberof OnecompilerV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface OnecompilerV1Response
 */
export interface OnecompilerV1Response {
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'kind': OnecompilerV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof OnecompilerV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof OnecompilerV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'status': OnecompilerV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof OnecompilerV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OnecompilerV1Response
     */
    'updatedAt': string;
}

export const OnecompilerV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type OnecompilerV1ResponseKindEnum = typeof OnecompilerV1ResponseKindEnum[keyof typeof OnecompilerV1ResponseKindEnum];
export const OnecompilerV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type OnecompilerV1ResponseStatusEnum = typeof OnecompilerV1ResponseStatusEnum[keyof typeof OnecompilerV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface OperationEntity
 */
export interface OperationEntity {
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'kind': OperationEntityKindEnum;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'input': object;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'output': object;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'status': OperationEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'updatedAt': string;
}

export const OperationEntityKindEnum = {
    Operation: 'operation'
} as const;

export type OperationEntityKindEnum = typeof OperationEntityKindEnum[keyof typeof OperationEntityKindEnum];
export const OperationEntityStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type OperationEntityStatusEnum = typeof OperationEntityStatusEnum[keyof typeof OperationEntityStatusEnum];

/**
 * 
 * @export
 * @interface OperationOutputImageMultiple
 */
export interface OperationOutputImageMultiple {
    /**
     * 
     * @type {string}
     * @memberof OperationOutputImageMultiple
     */
    'kind': OperationOutputImageMultipleKindEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof OperationOutputImageMultiple
     */
    'imageIds': Array<string>;
}

export const OperationOutputImageMultipleKindEnum = {
    ImageMultiple: 'image/multiple'
} as const;

export type OperationOutputImageMultipleKindEnum = typeof OperationOutputImageMultipleKindEnum[keyof typeof OperationOutputImageMultipleKindEnum];

/**
 * 
 * @export
 * @interface OperationOutputImageSingle
 */
export interface OperationOutputImageSingle {
    /**
     * 
     * @type {string}
     * @memberof OperationOutputImageSingle
     */
    'kind': OperationOutputImageSingleKindEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationOutputImageSingle
     */
    'imageId': string;
}

export const OperationOutputImageSingleKindEnum = {
    ImageSingle: 'image/single'
} as const;

export type OperationOutputImageSingleKindEnum = typeof OperationOutputImageSingleKindEnum[keyof typeof OperationOutputImageSingleKindEnum];

/**
 * 
 * @export
 * @interface OperationOutputJSON
 */
export interface OperationOutputJSON {
    /**
     * 
     * @type {string}
     * @memberof OperationOutputJSON
     */
    'kind': OperationOutputJSONKindEnum;
    /**
     * 
     * @type {object}
     * @memberof OperationOutputJSON
     */
    'data': object;
}

export const OperationOutputJSONKindEnum = {
    Json: 'json'
} as const;

export type OperationOutputJSONKindEnum = typeof OperationOutputJSONKindEnum[keyof typeof OperationOutputJSONKindEnum];

/**
 * 
 * @export
 * @interface OperationOutputTextSingle
 */
export interface OperationOutputTextSingle {
    /**
     * 
     * @type {string}
     * @memberof OperationOutputTextSingle
     */
    'kind': OperationOutputTextSingleKindEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationOutputTextSingle
     */
    'text': string;
}

export const OperationOutputTextSingleKindEnum = {
    TextSingle: 'text/single'
} as const;

export type OperationOutputTextSingleKindEnum = typeof OperationOutputTextSingleKindEnum[keyof typeof OperationOutputTextSingleKindEnum];

/**
 * 
 * @export
 * @interface OperationOutputVideoSingle
 */
export interface OperationOutputVideoSingle {
    /**
     * 
     * @type {string}
     * @memberof OperationOutputVideoSingle
     */
    'kind': OperationOutputVideoSingleKindEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationOutputVideoSingle
     */
    'videoId': string;
}

export const OperationOutputVideoSingleKindEnum = {
    VideoSingle: 'video/single'
} as const;

export type OperationOutputVideoSingleKindEnum = typeof OperationOutputVideoSingleKindEnum[keyof typeof OperationOutputVideoSingleKindEnum];

/**
 * 
 * @export
 * @interface PipelineDto
 */
export interface PipelineDto {
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'kind': PipelineDtoKindEnum;
    /**
     * State of the pipeline tasks
     * @type {{ [key: string]: PipelineDtoStateValue; }}
     * @memberof PipelineDto
     */
    'state': { [key: string]: PipelineDtoStateValue; };
    /**
     * Total estimated credits of all tasks in the pipeline as a decimal string
     * @type {string}
     * @memberof PipelineDto
     */
    'estimatedCredits': string;
    /**
     * Consumed credits of all successfully completed tasks in the pipeline as a decimal string
     * @type {string}
     * @memberof PipelineDto
     */
    'consumedCredits': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineDto
     */
    'output'?: object;
    /**
     * 
     * @type {object}
     * @memberof PipelineDto
     */
    'input'?: object;
    /**
     * 
     * @type {Array<TaskDto>}
     * @memberof PipelineDto
     */
    'tasks': Array<TaskDto>;
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineDto
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineDto
     */
    'status': PipelineDtoStatusEnum;
}

export const PipelineDtoKindEnum = {
    Pipeline: 'pipeline'
} as const;

export type PipelineDtoKindEnum = typeof PipelineDtoKindEnum[keyof typeof PipelineDtoKindEnum];
export const PipelineDtoStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type PipelineDtoStatusEnum = typeof PipelineDtoStatusEnum[keyof typeof PipelineDtoStatusEnum];

/**
 * 
 * @export
 * @interface PipelineDtoStateValue
 */
export interface PipelineDtoStateValue {
    /**
     * 
     * @type {string}
     * @memberof PipelineDtoStateValue
     */
    'status'?: PipelineDtoStateValueStatusEnum;
    /**
     * Output of the task
     * @type {object}
     * @memberof PipelineDtoStateValue
     */
    'output'?: object;
}

export const PipelineDtoStateValueStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type PipelineDtoStateValueStatusEnum = typeof PipelineDtoStateValueStatusEnum[keyof typeof PipelineDtoStateValueStatusEnum];

/**
 * 
 * @export
 * @interface PipelineMapV1Input
 */
export interface PipelineMapV1Input {
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Input
     */
    'pipeline': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof PipelineMapV1Input
     */
    'input': Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof PipelineMapV1Input
     */
    'failOnError'?: boolean;
}
/**
 * 
 * @export
 * @interface PipelineMapV1Request
 */
export interface PipelineMapV1Request {
    /**
     * 
     * @type {PipelineMapV1Input}
     * @memberof PipelineMapV1Request
     */
    'input': PipelineMapV1Input;
    /**
     * 
     * @type {object}
     * @memberof PipelineMapV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface PipelineMapV1Response
 */
export interface PipelineMapV1Response {
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'kind': PipelineMapV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof PipelineMapV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof PipelineMapV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'status': PipelineMapV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineMapV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineMapV1Response
     */
    'updatedAt': string;
}

export const PipelineMapV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type PipelineMapV1ResponseKindEnum = typeof PipelineMapV1ResponseKindEnum[keyof typeof PipelineMapV1ResponseKindEnum];
export const PipelineMapV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type PipelineMapV1ResponseStatusEnum = typeof PipelineMapV1ResponseStatusEnum[keyof typeof PipelineMapV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface PipelinePreviewDto
 */
export interface PipelinePreviewDto {
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'kind': PipelinePreviewDtoKindEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PipelinePreviewDto
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelinePreviewDto
     */
    'status': PipelinePreviewDtoStatusEnum;
}

export const PipelinePreviewDtoKindEnum = {
    Pipeline: 'pipeline'
} as const;

export type PipelinePreviewDtoKindEnum = typeof PipelinePreviewDtoKindEnum[keyof typeof PipelinePreviewDtoKindEnum];
export const PipelinePreviewDtoStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type PipelinePreviewDtoStatusEnum = typeof PipelinePreviewDtoStatusEnum[keyof typeof PipelinePreviewDtoStatusEnum];

/**
 * 
 * @export
 * @interface PoseEntity
 */
export interface PoseEntity {
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'kind': PoseEntityKindEnum;
    /**
     * 
     * @type {ImageEntity}
     * @memberof PoseEntity
     */
    'sourceImage': ImageEntity;
    /**
     * 
     * @type {ImageEntity}
     * @memberof PoseEntity
     */
    'previewImage'?: ImageEntity;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'previewImageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PoseEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'updatedAt': string;
}

export const PoseEntityKindEnum = {
    Pose: 'pose'
} as const;

export type PoseEntityKindEnum = typeof PoseEntityKindEnum[keyof typeof PoseEntityKindEnum];

/**
 * 
 * @export
 * @interface PoseEstimationV1Input
 */
export interface PoseEstimationV1Input {
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface PoseEstimationV1Request
 */
export interface PoseEstimationV1Request {
    /**
     * 
     * @type {PoseEstimationV1Input}
     * @memberof PoseEstimationV1Request
     */
    'input': PoseEstimationV1Input;
    /**
     * 
     * @type {object}
     * @memberof PoseEstimationV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface PoseEstimationV1Response
 */
export interface PoseEstimationV1Response {
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'kind': PoseEstimationV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof PoseEstimationV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof PoseEstimationV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'status': PoseEstimationV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PoseEstimationV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Response
     */
    'updatedAt': string;
}

export const PoseEstimationV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type PoseEstimationV1ResponseKindEnum = typeof PoseEstimationV1ResponseKindEnum[keyof typeof PoseEstimationV1ResponseKindEnum];
export const PoseEstimationV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type PoseEstimationV1ResponseStatusEnum = typeof PoseEstimationV1ResponseStatusEnum[keyof typeof PoseEstimationV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface RemoveAccountFromGroupControllerParamsDto
 */
export interface RemoveAccountFromGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'role': RemoveAccountFromGroupControllerParamsDtoRoleEnum;
}

export const RemoveAccountFromGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type RemoveAccountFromGroupControllerParamsDtoRoleEnum = typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum[keyof typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface RemoveAccountFromGroupParamsDto
 */
export interface RemoveAccountFromGroupParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupParamsDto
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupParamsDto
     */
    'role': RemoveAccountFromGroupParamsDtoRoleEnum;
}

export const RemoveAccountFromGroupParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type RemoveAccountFromGroupParamsDtoRoleEnum = typeof RemoveAccountFromGroupParamsDtoRoleEnum[keyof typeof RemoveAccountFromGroupParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface RemoveItemsFromCollectionControllerParamsDto
 */
export interface RemoveItemsFromCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveItemsFromCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RemoveItemsFromCollectionParamsDto
 */
export interface RemoveItemsFromCollectionParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveItemsFromCollectionParamsDto
     */
    'collectionId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveItemsFromCollectionParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RemoveItemsFromStackParamsDto
 */
export interface RemoveItemsFromStackParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveItemsFromStackParamsDto
     */
    'stackId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveItemsFromStackParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ResizeV1Input
 */
export interface ResizeV1Input {
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {number}
     * @memberof ResizeV1Input
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ResizeV1Input
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface ResizeV1Request
 */
export interface ResizeV1Request {
    /**
     * 
     * @type {ResizeV1Input}
     * @memberof ResizeV1Request
     */
    'input': ResizeV1Input;
    /**
     * 
     * @type {object}
     * @memberof ResizeV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ResizeV1Response
 */
export interface ResizeV1Response {
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'kind': ResizeV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof ResizeV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof ResizeV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'status': ResizeV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ResizeV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResizeV1Response
     */
    'updatedAt': string;
}

export const ResizeV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type ResizeV1ResponseKindEnum = typeof ResizeV1ResponseKindEnum[keyof typeof ResizeV1ResponseKindEnum];
export const ResizeV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type ResizeV1ResponseStatusEnum = typeof ResizeV1ResponseStatusEnum[keyof typeof ResizeV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ResourceEntity
 */
export interface ResourceEntity {
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'kind': ResourceEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ResourceEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'updatedAt': string;
}

export const ResourceEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;

export type ResourceEntityKindEnum = typeof ResourceEntityKindEnum[keyof typeof ResourceEntityKindEnum];

/**
 * 
 * @export
 * @interface RevokeAccessControllerParamsDto
 */
export interface RevokeAccessControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RevokeAccessControllerParamsDto
     */
    'principalType': RevokeAccessControllerParamsDtoPrincipalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RevokeAccessControllerParamsDto
     */
    'principalId': string;
    /**
     * 
     * @type {string}
     * @memberof RevokeAccessControllerParamsDto
     */
    'access': string;
}

export const RevokeAccessControllerParamsDtoPrincipalTypeEnum = {
    Account: 'account',
    Group: 'group'
} as const;

export type RevokeAccessControllerParamsDtoPrincipalTypeEnum = typeof RevokeAccessControllerParamsDtoPrincipalTypeEnum[keyof typeof RevokeAccessControllerParamsDtoPrincipalTypeEnum];

/**
 * 
 * @export
 * @interface RunWorkflowParamsDto
 */
export interface RunWorkflowParamsDto {
    /**
     * 
     * @type {object}
     * @memberof RunWorkflowParamsDto
     */
    'input': object;
    /**
     * 
     * @type {object}
     * @memberof RunWorkflowParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface RunWorkflowResponseDto
 */
export interface RunWorkflowResponseDto {
    /**
     * 
     * @type {string}
     * @memberof RunWorkflowResponseDto
     */
    'pipelineId': string;
}
/**
 * 
 * @export
 * @interface SegmentAnythingEmbeddingsV1Input
 */
export interface SegmentAnythingEmbeddingsV1Input {
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface SegmentAnythingEmbeddingsV1Request
 */
export interface SegmentAnythingEmbeddingsV1Request {
    /**
     * 
     * @type {SegmentAnythingEmbeddingsV1Input}
     * @memberof SegmentAnythingEmbeddingsV1Request
     */
    'input': SegmentAnythingEmbeddingsV1Input;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingEmbeddingsV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface SegmentAnythingEmbeddingsV1Response
 */
export interface SegmentAnythingEmbeddingsV1Response {
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'kind': SegmentAnythingEmbeddingsV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'status': SegmentAnythingEmbeddingsV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Response
     */
    'updatedAt': string;
}

export const SegmentAnythingEmbeddingsV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type SegmentAnythingEmbeddingsV1ResponseKindEnum = typeof SegmentAnythingEmbeddingsV1ResponseKindEnum[keyof typeof SegmentAnythingEmbeddingsV1ResponseKindEnum];
export const SegmentAnythingEmbeddingsV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type SegmentAnythingEmbeddingsV1ResponseStatusEnum = typeof SegmentAnythingEmbeddingsV1ResponseStatusEnum[keyof typeof SegmentAnythingEmbeddingsV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface SegmentAnythingMaskV1Input
 */
export interface SegmentAnythingMaskV1Input {
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Input
     */
    'imageId': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SegmentAnythingMaskV1Input
     */
    'box': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SegmentAnythingMaskV1Input
     */
    'smoothness'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentAnythingMaskV1Input
     */
    'maskThreshold'?: number;
}
/**
 * 
 * @export
 * @interface SegmentAnythingMaskV1Request
 */
export interface SegmentAnythingMaskV1Request {
    /**
     * 
     * @type {SegmentAnythingMaskV1Input}
     * @memberof SegmentAnythingMaskV1Request
     */
    'input': SegmentAnythingMaskV1Input;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingMaskV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface SegmentAnythingMaskV1Response
 */
export interface SegmentAnythingMaskV1Response {
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'kind': SegmentAnythingMaskV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof SegmentAnythingMaskV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingMaskV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'status': SegmentAnythingMaskV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingMaskV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingMaskV1Response
     */
    'updatedAt': string;
}

export const SegmentAnythingMaskV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type SegmentAnythingMaskV1ResponseKindEnum = typeof SegmentAnythingMaskV1ResponseKindEnum[keyof typeof SegmentAnythingMaskV1ResponseKindEnum];
export const SegmentAnythingMaskV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type SegmentAnythingMaskV1ResponseStatusEnum = typeof SegmentAnythingMaskV1ResponseStatusEnum[keyof typeof SegmentAnythingMaskV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface SelfAccountDto
 */
export interface SelfAccountDto {
    /**
     * 
     * @type {string}
     * @memberof SelfAccountDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SelfAccountDto
     */
    'alias'?: string;
    /**
     * 
     * @type {object}
     * @memberof SelfAccountDto
     */
    'permissions': object;
    /**
     * 
     * @type {string}
     * @memberof SelfAccountDto
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof SelfAccountDto
     */
    'type': SelfAccountDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SelfAccountDto
     */
    'createdAt': string;
}

export const SelfAccountDtoTypeEnum = {
    Root: 'root',
    User: 'user'
} as const;

export type SelfAccountDtoTypeEnum = typeof SelfAccountDtoTypeEnum[keyof typeof SelfAccountDtoTypeEnum];

/**
 * 
 * @export
 * @interface SetPosePreviewControllerParamsDto
 */
export interface SetPosePreviewControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof SetPosePreviewControllerParamsDto
     */
    'previewImageId': string;
}
/**
 * 
 * @export
 * @interface SetPosePreviewDto
 */
export interface SetPosePreviewDto {
    /**
     * 
     * @type {string}
     * @memberof SetPosePreviewDto
     */
    'poseId': string;
    /**
     * 
     * @type {string}
     * @memberof SetPosePreviewDto
     */
    'previewImageId': string;
}
/**
 * 
 * @export
 * @interface StackEntity
 */
export interface StackEntity {
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'kind': StackEntityKindEnum;
    /**
     * 
     * @type {Array<StackEntityItemsInner>}
     * @memberof StackEntity
     */
    'items': Array<StackEntityItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StackEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'updatedAt': string;
}

export const StackEntityKindEnum = {
    Stack: 'stack'
} as const;

export type StackEntityKindEnum = typeof StackEntityKindEnum[keyof typeof StackEntityKindEnum];

/**
 * @type StackEntityItemsInner
 * @export
 */
export type StackEntityItemsInner = ImageEntity | OperationEntity | VideoEntity;

/**
 * 
 * @export
 * @interface StorageEntity
 */
export interface StorageEntity {
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'kind': StorageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'value': object;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'updatedAt': string;
}

export const StorageEntityKindEnum = {
    Storage: 'storage'
} as const;

export type StorageEntityKindEnum = typeof StorageEntityKindEnum[keyof typeof StorageEntityKindEnum];

/**
 * 
 * @export
 * @interface StorageRecordsResultDto
 */
export interface StorageRecordsResultDto {
    /**
     * 
     * @type {string}
     * @memberof StorageRecordsResultDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageRecordsResultDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface StringsTemplateV1Input
 */
export interface StringsTemplateV1Input {
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Input
     */
    'template': string;
    /**
     * 
     * @type {Array<VariableDto>}
     * @memberof StringsTemplateV1Input
     */
    'variables': Array<VariableDto>;
}
/**
 * 
 * @export
 * @interface StringsTemplateV1Request
 */
export interface StringsTemplateV1Request {
    /**
     * 
     * @type {StringsTemplateV1Input}
     * @memberof StringsTemplateV1Request
     */
    'input': StringsTemplateV1Input;
    /**
     * 
     * @type {object}
     * @memberof StringsTemplateV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface StringsTemplateV1Response
 */
export interface StringsTemplateV1Response {
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'kind': StringsTemplateV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputTextSingle}
     * @memberof StringsTemplateV1Response
     */
    'output': OperationOutputTextSingle;
    /**
     * 
     * @type {object}
     * @memberof StringsTemplateV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'status': StringsTemplateV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StringsTemplateV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StringsTemplateV1Response
     */
    'updatedAt': string;
}

export const StringsTemplateV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type StringsTemplateV1ResponseKindEnum = typeof StringsTemplateV1ResponseKindEnum[keyof typeof StringsTemplateV1ResponseKindEnum];
export const StringsTemplateV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type StringsTemplateV1ResponseStatusEnum = typeof StringsTemplateV1ResponseStatusEnum[keyof typeof StringsTemplateV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface SupportFile
 */
export interface SupportFile {
    /**
     * 
     * @type {string}
     * @memberof SupportFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SupportFile
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDto
     */
    'method': Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof TaskDto
     */
    'args': Array<object>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDto
     */
    'dependencies': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'estimatedPrice': string;
}
/**
 * 
 * @export
 * @interface TranslateV1Input
 */
export interface TranslateV1Input {
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Input
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Input
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface TranslateV1Request
 */
export interface TranslateV1Request {
    /**
     * 
     * @type {TranslateV1Input}
     * @memberof TranslateV1Request
     */
    'input': TranslateV1Input;
    /**
     * 
     * @type {object}
     * @memberof TranslateV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface TranslateV1Response
 */
export interface TranslateV1Response {
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'kind': TranslateV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputJSON}
     * @memberof TranslateV1Response
     */
    'output': OperationOutputJSON;
    /**
     * 
     * @type {object}
     * @memberof TranslateV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'status': TranslateV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof TranslateV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TranslateV1Response
     */
    'updatedAt': string;
}

export const TranslateV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type TranslateV1ResponseKindEnum = typeof TranslateV1ResponseKindEnum[keyof typeof TranslateV1ResponseKindEnum];
export const TranslateV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type TranslateV1ResponseStatusEnum = typeof TranslateV1ResponseStatusEnum[keyof typeof TranslateV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UpdateAccountParamsDto
 */
export interface UpdateAccountParamsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountParamsDto
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetadataDto
 */
export interface UpdateMetadataDto {
    /**
     * 
     * @type {object}
     * @memberof UpdateMetadataDto
     */
    'overwrite': object;
}
/**
 * 
 * @export
 * @interface UpdateResourceMetadataDto
 */
export interface UpdateResourceMetadataDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceMetadataDto
     */
    'id': string;
    /**
     * 
     * @type {UpdateMetadataDto}
     * @memberof UpdateResourceMetadataDto
     */
    'update': UpdateMetadataDto;
}
/**
 * 
 * @export
 * @interface UpdateStorageRecordParamsDto
 */
export interface UpdateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof UpdateStorageRecordParamsDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface UpdateWorkflowParamsDto
 */
export interface UpdateWorkflowParamsDto {
    /**
     * 
     * @type {object}
     * @memberof UpdateWorkflowParamsDto
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkflowParamsDto
     */
    'version'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateWorkflowParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface UpscaleV1Input
 */
export interface UpscaleV1Input {
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface UpscaleV1Request
 */
export interface UpscaleV1Request {
    /**
     * 
     * @type {UpscaleV1Input}
     * @memberof UpscaleV1Request
     */
    'input': UpscaleV1Input;
    /**
     * 
     * @type {object}
     * @memberof UpscaleV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface UpscaleV1Response
 */
export interface UpscaleV1Response {
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'kind': UpscaleV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof UpscaleV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof UpscaleV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'status': UpscaleV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof UpscaleV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Response
     */
    'updatedAt': string;
}

export const UpscaleV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type UpscaleV1ResponseKindEnum = typeof UpscaleV1ResponseKindEnum[keyof typeof UpscaleV1ResponseKindEnum];
export const UpscaleV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type UpscaleV1ResponseStatusEnum = typeof UpscaleV1ResponseStatusEnum[keyof typeof UpscaleV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface VariableDto
 */
export interface VariableDto {
    /**
     * 
     * @type {string}
     * @memberof VariableDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariableDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface VideoEntity
 */
export interface VideoEntity {
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'kind': VideoEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof VideoEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof VideoEntity
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof VideoEntity
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof VideoEntity
     */
    'duration': number;
    /**
     * 
     * @type {ImageEntity}
     * @memberof VideoEntity
     */
    'previewImage'?: ImageEntity;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'previewImageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoEntity
     */
    'url': string;
}

export const VideoEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;

export type VideoEntityKindEnum = typeof VideoEntityKindEnum[keyof typeof VideoEntityKindEnum];

/**
 * 
 * @export
 * @interface VideoUrlResponseDto
 */
export interface VideoUrlResponseDto {
    /**
     * 
     * @type {string}
     * @memberof VideoUrlResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VideoUrlResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface VtonGiseleV1Request
 */
export interface VtonGiseleV1Request {
    /**
     * 
     * @type {GiseleVtonV1Input}
     * @memberof VtonGiseleV1Request
     */
    'input': GiseleVtonV1Input;
    /**
     * 
     * @type {object}
     * @memberof VtonGiseleV1Request
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface VtonGiseleV1Response
 */
export interface VtonGiseleV1Response {
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'kind': VtonGiseleV1ResponseKindEnum;
    /**
     * 
     * @type {OperationOutputImageSingle}
     * @memberof VtonGiseleV1Response
     */
    'output': OperationOutputImageSingle;
    /**
     * 
     * @type {object}
     * @memberof VtonGiseleV1Response
     */
    'input': object;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'status': VtonGiseleV1ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof VtonGiseleV1Response
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof VtonGiseleV1Response
     */
    'updatedAt': string;
}

export const VtonGiseleV1ResponseKindEnum = {
    Operation: 'operation'
} as const;

export type VtonGiseleV1ResponseKindEnum = typeof VtonGiseleV1ResponseKindEnum[keyof typeof VtonGiseleV1ResponseKindEnum];
export const VtonGiseleV1ResponseStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type VtonGiseleV1ResponseStatusEnum = typeof VtonGiseleV1ResponseStatusEnum[keyof typeof VtonGiseleV1ResponseStatusEnum];

/**
 * 
 * @export
 * @interface WaitOperationParamsDto
 */
export interface WaitOperationParamsDto {
    /**
     * 
     * @type {string}
     * @memberof WaitOperationParamsDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface WorkflowDto
 */
export interface WorkflowDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof WorkflowDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'version': string;
    /**
     * 
     * @type {object}
     * @memberof WorkflowDto
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'updatedAt': string;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary UNSTABLE
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAccessV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessControllerAccessV1', 'id', id)
            const localVarPath = `/v1/resources/{id}/access`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AttachAccessControllerParamsDto} attachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAttachAccessV1: async (id: string, attachAccessControllerParamsDto: AttachAccessControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessControllerAttachAccessV1', 'id', id)
            // verify required parameter 'attachAccessControllerParamsDto' is not null or undefined
            assertParamExists('accessControllerAttachAccessV1', 'attachAccessControllerParamsDto', attachAccessControllerParamsDto)
            const localVarPath = `/v1/resources/{id}/access/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachAccessControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DetachAccessControllerParamsDto} detachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerDetachAccessV1: async (id: string, detachAccessControllerParamsDto: DetachAccessControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessControllerDetachAccessV1', 'id', id)
            // verify required parameter 'detachAccessControllerParamsDto' is not null or undefined
            assertParamExists('accessControllerDetachAccessV1', 'detachAccessControllerParamsDto', detachAccessControllerParamsDto)
            const localVarPath = `/v1/resources/{id}/access/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detachAccessControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {GrantAccessControllerParams} grantAccessControllerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerGrantAccessV1: async (id: string, grantAccessControllerParams: GrantAccessControllerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessControllerGrantAccessV1', 'id', id)
            // verify required parameter 'grantAccessControllerParams' is not null or undefined
            assertParamExists('accessControllerGrantAccessV1', 'grantAccessControllerParams', grantAccessControllerParams)
            const localVarPath = `/v1/resources/{id}/access/grant`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(grantAccessControllerParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RevokeAccessControllerParamsDto} revokeAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerRevokeAccessV1: async (id: string, revokeAccessControllerParamsDto: RevokeAccessControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessControllerRevokeAccessV1', 'id', id)
            // verify required parameter 'revokeAccessControllerParamsDto' is not null or undefined
            assertParamExists('accessControllerRevokeAccessV1', 'revokeAccessControllerParamsDto', revokeAccessControllerParamsDto)
            const localVarPath = `/v1/resources/{id}/access/revoke`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeAccessControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary UNSTABLE
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerAccessV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccessControllerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerAccessV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {AttachAccessControllerParamsDto} attachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerAttachAccessV1(id: string, attachAccessControllerParamsDto: AttachAccessControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerAttachAccessV1(id, attachAccessControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerAttachAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DetachAccessControllerParamsDto} detachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerDetachAccessV1(id: string, detachAccessControllerParamsDto: DetachAccessControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerDetachAccessV1(id, detachAccessControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerDetachAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {GrantAccessControllerParams} grantAccessControllerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerGrantAccessV1(id: string, grantAccessControllerParams: GrantAccessControllerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerGrantAccessV1(id, grantAccessControllerParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerGrantAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RevokeAccessControllerParamsDto} revokeAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerRevokeAccessV1(id: string, revokeAccessControllerParamsDto: RevokeAccessControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerRevokeAccessV1(id, revokeAccessControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerRevokeAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessApiFp(configuration)
    return {
        /**
         * 
         * @summary UNSTABLE
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAccessV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAccessControllerDto> {
            return localVarFp.accessControllerAccessV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AttachAccessControllerParamsDto} attachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAttachAccessV1(id: string, attachAccessControllerParamsDto: AttachAccessControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerAttachAccessV1(id, attachAccessControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DetachAccessControllerParamsDto} detachAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerDetachAccessV1(id: string, detachAccessControllerParamsDto: DetachAccessControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerDetachAccessV1(id, detachAccessControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {GrantAccessControllerParams} grantAccessControllerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerGrantAccessV1(id: string, grantAccessControllerParams: GrantAccessControllerParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerGrantAccessV1(id, grantAccessControllerParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RevokeAccessControllerParamsDto} revokeAccessControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerRevokeAccessV1(id: string, revokeAccessControllerParamsDto: RevokeAccessControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerRevokeAccessV1(id, revokeAccessControllerParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * 
     * @summary UNSTABLE
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerAccessV1(id: string, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerAccessV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AttachAccessControllerParamsDto} attachAccessControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerAttachAccessV1(id: string, attachAccessControllerParamsDto: AttachAccessControllerParamsDto, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerAttachAccessV1(id, attachAccessControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DetachAccessControllerParamsDto} detachAccessControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerDetachAccessV1(id: string, detachAccessControllerParamsDto: DetachAccessControllerParamsDto, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerDetachAccessV1(id, detachAccessControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {GrantAccessControllerParams} grantAccessControllerParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerGrantAccessV1(id: string, grantAccessControllerParams: GrantAccessControllerParams, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerGrantAccessV1(id, grantAccessControllerParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RevokeAccessControllerParamsDto} revokeAccessControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerRevokeAccessV1(id: string, revokeAccessControllerParamsDto: RevokeAccessControllerParamsDto, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerRevokeAccessV1(id, revokeAccessControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1: async (createAccountParamsDto: CreateAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountParamsDto' is not null or undefined
            assertParamExists('accountsControllerCreateAccountV1', 'createAccountParamsDto', createAccountParamsDto)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountByAliasV1', 'id', id)
            const localVarPath = `/v1/accounts/alias/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountsControllerListAccountsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {Array<string>} [ids] 
         * @param {Array<string>} [aliases] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerListAccountsV1: async (orderBy?: AccountsControllerListAccountsV1OrderByEnum, limit?: number, ids?: Array<string>, aliases?: Array<string>, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (aliases) {
                localVarQueryParameter['aliases'] = aliases;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAccountParamsDto} updateAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdateAccountV1: async (id: string, updateAccountParamsDto: UpdateAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerUpdateAccountV1', 'id', id)
            // verify required parameter 'updateAccountParamsDto' is not null or undefined
            assertParamExists('accountsControllerUpdateAccountV1', 'updateAccountParamsDto', updateAccountParamsDto)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreateAccountV1(createAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerCreateAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountByAliasV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountByAliasV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountsControllerListAccountsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {Array<string>} [ids] 
         * @param {Array<string>} [aliases] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerListAccountsV1(orderBy?: AccountsControllerListAccountsV1OrderByEnum, limit?: number, ids?: Array<string>, aliases?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerListAccountsV1(orderBy, limit, ids, aliases, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerListAccountsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAccountParamsDto} updateAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerUpdateAccountV1(id: string, updateAccountParamsDto: UpdateAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerUpdateAccountV1(id, updateAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerUpdateAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountByAliasV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<SelfAccountDto> {
            return localVarFp.accountsControllerGetSelfV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsControllerListAccountsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {Array<string>} [ids] 
         * @param {Array<string>} [aliases] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerListAccountsV1(orderBy?: AccountsControllerListAccountsV1OrderByEnum, limit?: number, ids?: Array<string>, aliases?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsDto> {
            return localVarFp.accountsControllerListAccountsV1(orderBy, limit, ids, aliases, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAccountParamsDto} updateAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdateAccountV1(id: string, updateAccountParamsDto: UpdateAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerUpdateAccountV1(id, updateAccountParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAccountParamsDto} createAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountByAliasV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetSelfV1(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetSelfV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsControllerListAccountsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {Array<string>} [ids] 
     * @param {Array<string>} [aliases] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerListAccountsV1(orderBy?: AccountsControllerListAccountsV1OrderByEnum, limit?: number, ids?: Array<string>, aliases?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerListAccountsV1(orderBy, limit, ids, aliases, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateAccountParamsDto} updateAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerUpdateAccountV1(id: string, updateAccountParamsDto: UpdateAccountParamsDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerUpdateAccountV1(id, updateAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AccountsControllerListAccountsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC'
} as const;
export type AccountsControllerListAccountsV1OrderByEnum = typeof AccountsControllerListAccountsV1OrderByEnum[keyof typeof AccountsControllerListAccountsV1OrderByEnum];


/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1: async (id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'id', id)
            // verify required parameter 'addBalanceControllerParamsDto' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'addBalanceControllerParamsDto', addBalanceControllerParamsDto)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBalanceControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerGetBalanceV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerAddBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceForSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceForSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceForSelfV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceV1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceForSelfV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceV1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallApi - axios parameter creator
 * @export
 */
export const CallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AttachAccessParamsDto} attachAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccessAttachV1: async (attachAccessParamsDto: AttachAccessParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachAccessParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccessAttachV1', 'attachAccessParamsDto', attachAccessParamsDto)
            const localVarPath = `/v1/call/access.attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachAccessParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModifyAccessParamsDto} modifyAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccessGrantV1: async (modifyAccessParamsDto: ModifyAccessParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifyAccessParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccessGrantV1', 'modifyAccessParamsDto', modifyAccessParamsDto)
            const localVarPath = `/v1/call/access.grant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyAccessParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddBalanceParamsDto} addBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceAddV1: async (addBalanceParamsDto: AddBalanceParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addBalanceParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccountsBalanceAddV1', 'addBalanceParamsDto', addBalanceParamsDto)
            const localVarPath = `/v1/call/accounts.balance.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBalanceParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetBalanceParamsDto} getBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceGetV1: async (getBalanceParamsDto: GetBalanceParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getBalanceParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccountsBalanceGetV1', 'getBalanceParamsDto', getBalanceParamsDto)
            const localVarPath = `/v1/call/accounts.balance.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getBalanceParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceSelfV1: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('callControllerCallAccountsBalanceSelfV1', 'body', body)
            const localVarPath = `/v1/call/accounts.balance.self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsCreateV1: async (createAccountParamsDto: CreateAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccountsCreateV1', 'createAccountParamsDto', createAccountParamsDto)
            const localVarPath = `/v1/call/accounts.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAccountParamsDto} getAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsGetV1: async (getAccountParamsDto: GetAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAccountParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccountsGetV1', 'getAccountParamsDto', getAccountParamsDto)
            const localVarPath = `/v1/call/accounts.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListAccountsParamsDto} listAccountsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsListV1: async (listAccountsParamsDto: ListAccountsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listAccountsParamsDto' is not null or undefined
            assertParamExists('callControllerCallAccountsListV1', 'listAccountsParamsDto', listAccountsParamsDto)
            const localVarPath = `/v1/call/accounts.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listAccountsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsSelfV1: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('callControllerCallAccountsSelfV1', 'body', body)
            const localVarPath = `/v1/call/accounts.self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsCreateV1: async (createCollectionParamsDto: CreateCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCollectionParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsCreateV1', 'createCollectionParamsDto', createCollectionParamsDto)
            const localVarPath = `/v1/call/collections.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetCollectionParamsDto} getCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsGetV1: async (getCollectionParamsDto: GetCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getCollectionParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsGetV1', 'getCollectionParamsDto', getCollectionParamsDto)
            const localVarPath = `/v1/call/collections.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddItemsToCollectionParamsDto} addItemsToCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsAddV1: async (addItemsToCollectionParamsDto: AddItemsToCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addItemsToCollectionParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsItemsAddV1', 'addItemsToCollectionParamsDto', addItemsToCollectionParamsDto)
            const localVarPath = `/v1/call/collections.items.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListCollectionItemsParamsDto} listCollectionItemsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsListV1: async (listCollectionItemsParamsDto: ListCollectionItemsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listCollectionItemsParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsItemsListV1', 'listCollectionItemsParamsDto', listCollectionItemsParamsDto)
            const localVarPath = `/v1/call/collections.items.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listCollectionItemsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveItemsFromCollectionParamsDto} removeItemsFromCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsRemoveV1: async (removeItemsFromCollectionParamsDto: RemoveItemsFromCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeItemsFromCollectionParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsItemsRemoveV1', 'removeItemsFromCollectionParamsDto', removeItemsFromCollectionParamsDto)
            const localVarPath = `/v1/call/collections.items.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListCollectionsParamsDto} listCollectionsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsListV1: async (listCollectionsParamsDto: ListCollectionsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listCollectionsParamsDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsListV1', 'listCollectionsParamsDto', listCollectionsParamsDto)
            const localVarPath = `/v1/call/collections.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listCollectionsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsMetadataUpdateV1: async (updateResourceMetadataDto: UpdateResourceMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResourceMetadataDto' is not null or undefined
            assertParamExists('callControllerCallCollectionsMetadataUpdateV1', 'updateResourceMetadataDto', updateResourceMetadataDto)
            const localVarPath = `/v1/call/collections.metadata.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddAccountToGroupParamsDto} addAccountToGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsAccountsAddV1: async (addAccountToGroupParamsDto: AddAccountToGroupParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAccountToGroupParamsDto' is not null or undefined
            assertParamExists('callControllerCallGroupsAccountsAddV1', 'addAccountToGroupParamsDto', addAccountToGroupParamsDto)
            const localVarPath = `/v1/call/groups.accounts.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountToGroupParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveAccountFromGroupParamsDto} removeAccountFromGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsAccountsRemoveV1: async (removeAccountFromGroupParamsDto: RemoveAccountFromGroupParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeAccountFromGroupParamsDto' is not null or undefined
            assertParamExists('callControllerCallGroupsAccountsRemoveV1', 'removeAccountFromGroupParamsDto', removeAccountFromGroupParamsDto)
            const localVarPath = `/v1/call/groups.accounts.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountFromGroupParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsCreateV1: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('callControllerCallGroupsCreateV1', 'body', body)
            const localVarPath = `/v1/call/groups.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteParamsDto} deleteParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsDeleteV1: async (deleteParamsDto: DeleteParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteParamsDto' is not null or undefined
            assertParamExists('callControllerCallGroupsDeleteV1', 'deleteParamsDto', deleteParamsDto)
            const localVarPath = `/v1/call/groups.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetGroupParamsDto} getGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsGetV1: async (getGroupParamsDto: GetGroupParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getGroupParamsDto' is not null or undefined
            assertParamExists('callControllerCallGroupsGetV1', 'getGroupParamsDto', getGroupParamsDto)
            const localVarPath = `/v1/call/groups.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getGroupParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesGetManyV1: async (getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUrlsForImagesParamsDto' is not null or undefined
            assertParamExists('callControllerCallImagesGetManyV1', 'getUrlsForImagesParamsDto', getUrlsForImagesParamsDto)
            const localVarPath = `/v1/call/images.getMany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUrlsForImagesParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetImageParamsDto} getImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesGetV1: async (getImageParamsDto: GetImageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getImageParamsDto' is not null or undefined
            assertParamExists('callControllerCallImagesGetV1', 'getImageParamsDto', getImageParamsDto)
            const localVarPath = `/v1/call/images.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getImageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetImageRepresentationParamsDto} getImageRepresentationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesRepresentationsGetV1: async (getImageRepresentationParamsDto: GetImageRepresentationParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getImageRepresentationParamsDto' is not null or undefined
            assertParamExists('callControllerCallImagesRepresentationsGetV1', 'getImageRepresentationParamsDto', getImageRepresentationParamsDto)
            const localVarPath = `/v1/call/images.representations.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getImageRepresentationParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsGetManyV1: async (getOperationsParamsDto: GetOperationsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOperationsParamsDto' is not null or undefined
            assertParamExists('callControllerCallOperationsGetManyV1', 'getOperationsParamsDto', getOperationsParamsDto)
            const localVarPath = `/v1/call/operations.getMany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOperationsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOperationParamsDto} getOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsGetV1: async (getOperationParamsDto: GetOperationParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOperationParamsDto' is not null or undefined
            assertParamExists('callControllerCallOperationsGetV1', 'getOperationParamsDto', getOperationParamsDto)
            const localVarPath = `/v1/call/operations.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOperationParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListOperationsParamsDto} listOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsListV1: async (listOperationsParamsDto: ListOperationsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listOperationsParamsDto' is not null or undefined
            assertParamExists('callControllerCallOperationsListV1', 'listOperationsParamsDto', listOperationsParamsDto)
            const localVarPath = `/v1/call/operations.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listOperationsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsMetadataUpdateV1: async (updateResourceMetadataDto: UpdateResourceMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResourceMetadataDto' is not null or undefined
            assertParamExists('callControllerCallOperationsMetadataUpdateV1', 'updateResourceMetadataDto', updateResourceMetadataDto)
            const localVarPath = `/v1/call/operations.metadata.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateCreatomateV1V1: async (animateCreatomateV1Request: AnimateCreatomateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateCreatomateV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunAnimateCreatomateV1V1', 'animateCreatomateV1Request', animateCreatomateV1Request)
            const localVarPath = `/v1/call/operations.run.animate.creatomate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateCreatomateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateKling16ProV1V1: async (animateKling16ProV1Request: AnimateKling16ProV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateKling16ProV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunAnimateKling16ProV1V1', 'animateKling16ProV1Request', animateKling16ProV1Request)
            const localVarPath = `/v1/call/operations.run.animate.kling_1_6_pro.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateKling16ProV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateKling21V1V1: async (animateKling21V1Request: AnimateKling21V1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateKling21V1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunAnimateKling21V1V1', 'animateKling21V1Request', animateKling21V1Request)
            const localVarPath = `/v1/call/operations.run.animate.kling_2_1.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateKling21V1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCompositeV1V1: async (compositeV1Request: CompositeV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunCompositeV1V1', 'compositeV1Request', compositeV1Request)
            const localVarPath = `/v1/call/operations.run.composite.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compositeV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunContrastV1V1: async (contrastV1Request: ContrastV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contrastV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunContrastV1V1', 'contrastV1Request', contrastV1Request)
            const localVarPath = `/v1/call/operations.run.contrast.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contrastV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCropV1V1: async (cropV1Request: CropV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cropV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunCropV1V1', 'cropV1Request', cropV1Request)
            const localVarPath = `/v1/call/operations.run.crop.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cropV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCutV1V1: async (cutV1Request: CutV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cutV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunCutV1V1', 'cutV1Request', cutV1Request)
            const localVarPath = `/v1/call/operations.run.cut.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cutV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunEchoV1V1: async (echoV1Request: EchoV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'echoV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunEchoV1V1', 'echoV1Request', echoV1Request)
            const localVarPath = `/v1/call/operations.run.echo.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(echoV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunEditFluxKontextDevV1V1: async (editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editFluxKontextDevV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunEditFluxKontextDevV1V1', 'editFluxKontextDevV1Request', editFluxKontextDevV1Request)
            const localVarPath = `/v1/call/operations.run.edit.flux_kontext_dev.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editFluxKontextDevV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunGptV1V1: async (gptV1Request: GptV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gptV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunGptV1V1', 'gptV1Request', gptV1Request)
            const localVarPath = `/v1/call/operations.run.gpt.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gptV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunGptV2V1: async (gptV2Request: GptV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gptV2Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunGptV2V1', 'gptV2Request', gptV2Request)
            const localVarPath = `/v1/call/operations.run.gpt.v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gptV2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunHauteLindaV1V1: async (hauteLindaV1Request: HauteLindaV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hauteLindaV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunHauteLindaV1V1', 'hauteLindaV1Request', hauteLindaV1Request)
            const localVarPath = `/v1/call/operations.run.haute.linda.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hauteLindaV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunHauteNaomiV1V1: async (hauteNaomiV1Request: HauteNaomiV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hauteNaomiV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunHauteNaomiV1V1', 'hauteNaomiV1Request', hauteNaomiV1Request)
            const localVarPath = `/v1/call/operations.run.haute.naomi.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hauteNaomiV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunImagineKateV1V1: async (imagineKateV1Request: ImagineKateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagineKateV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunImagineKateV1V1', 'imagineKateV1Request', imagineKateV1Request)
            const localVarPath = `/v1/call/operations.run.imagine.kate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagineKateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunInpaintKateV1V1: async (inpaintKateV1Request: InpaintKateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inpaintKateV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunInpaintKateV1V1', 'inpaintKateV1Request', inpaintKateV1Request)
            const localVarPath = `/v1/call/operations.run.inpaint.kate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inpaintKateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunMathV1V1: async (mathV1Request: MathV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mathV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunMathV1V1', 'mathV1Request', mathV1Request)
            const localVarPath = `/v1/call/operations.run.math.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mathV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunNegateImageV1V1: async (negateImageV1Request: NegateImageV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'negateImageV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunNegateImageV1V1', 'negateImageV1Request', negateImageV1Request)
            const localVarPath = `/v1/call/operations.run.negateImage.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(negateImageV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunNoiseV1V1: async (noiseV1Request: NoiseV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noiseV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunNoiseV1V1', 'noiseV1Request', noiseV1Request)
            const localVarPath = `/v1/call/operations.run.noise.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noiseV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunObjectDetectionV1V1: async (objectDetectionV1Request: ObjectDetectionV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectDetectionV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunObjectDetectionV1V1', 'objectDetectionV1Request', objectDetectionV1Request)
            const localVarPath = `/v1/call/operations.run.objectDetection.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectDetectionV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunOnecompilerV1V1: async (onecompilerV1Request: OnecompilerV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'onecompilerV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunOnecompilerV1V1', 'onecompilerV1Request', onecompilerV1Request)
            const localVarPath = `/v1/call/operations.run.onecompiler.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onecompilerV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunPipelineMapV1V1: async (pipelineMapV1Request: PipelineMapV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineMapV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunPipelineMapV1V1', 'pipelineMapV1Request', pipelineMapV1Request)
            const localVarPath = `/v1/call/operations.run.pipelineMap.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineMapV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunPoseEstimationV1V1: async (poseEstimationV1Request: PoseEstimationV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poseEstimationV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunPoseEstimationV1V1', 'poseEstimationV1Request', poseEstimationV1Request)
            const localVarPath = `/v1/call/operations.run.poseEstimation.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(poseEstimationV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunResizeV1V1: async (resizeV1Request: ResizeV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resizeV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunResizeV1V1', 'resizeV1Request', resizeV1Request)
            const localVarPath = `/v1/call/operations.run.resize.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resizeV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1: async (segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentAnythingEmbeddingsV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1', 'segmentAnythingEmbeddingsV1Request', segmentAnythingEmbeddingsV1Request)
            const localVarPath = `/v1/call/operations.run.segmentAnything.embeddings.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentAnythingEmbeddingsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunSegmentAnythingMaskV1V1: async (segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentAnythingMaskV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunSegmentAnythingMaskV1V1', 'segmentAnythingMaskV1Request', segmentAnythingMaskV1Request)
            const localVarPath = `/v1/call/operations.run.segmentAnything.mask.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentAnythingMaskV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunStringsTemplateV1V1: async (stringsTemplateV1Request: StringsTemplateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stringsTemplateV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunStringsTemplateV1V1', 'stringsTemplateV1Request', stringsTemplateV1Request)
            const localVarPath = `/v1/call/operations.run.strings.template.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stringsTemplateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunTranslateV1V1: async (translateV1Request: TranslateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translateV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunTranslateV1V1', 'translateV1Request', translateV1Request)
            const localVarPath = `/v1/call/operations.run.translate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunUpscaleV1V1: async (upscaleV1Request: UpscaleV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upscaleV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunUpscaleV1V1', 'upscaleV1Request', upscaleV1Request)
            const localVarPath = `/v1/call/operations.run.upscale.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upscaleV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunVtonGiseleV1V1: async (vtonGiseleV1Request: VtonGiseleV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vtonGiseleV1Request' is not null or undefined
            assertParamExists('callControllerCallOperationsRunVtonGiseleV1V1', 'vtonGiseleV1Request', vtonGiseleV1Request)
            const localVarPath = `/v1/call/operations.run.vton.gisele.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vtonGiseleV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WaitOperationParamsDto} waitOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsWaitV1: async (waitOperationParamsDto: WaitOperationParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitOperationParamsDto' is not null or undefined
            assertParamExists('callControllerCallOperationsWaitV1', 'waitOperationParamsDto', waitOperationParamsDto)
            const localVarPath = `/v1/call/operations.wait`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(waitOperationParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetPoseParamsDto} getPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesGetV1: async (getPoseParamsDto: GetPoseParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getPoseParamsDto' is not null or undefined
            assertParamExists('callControllerCallPosesGetV1', 'getPoseParamsDto', getPoseParamsDto)
            const localVarPath = `/v1/call/poses.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPoseParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListPosesParamsDto} listPosesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesListV1: async (listPosesParamsDto: ListPosesParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPosesParamsDto' is not null or undefined
            assertParamExists('callControllerCallPosesListV1', 'listPosesParamsDto', listPosesParamsDto)
            const localVarPath = `/v1/call/poses.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPosesParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesMetadataUpdateV1: async (updateResourceMetadataDto: UpdateResourceMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResourceMetadataDto' is not null or undefined
            assertParamExists('callControllerCallPosesMetadataUpdateV1', 'updateResourceMetadataDto', updateResourceMetadataDto)
            const localVarPath = `/v1/call/poses.metadata.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPosePreviewDto} setPosePreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesPreviewSetV1: async (setPosePreviewDto: SetPosePreviewDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setPosePreviewDto' is not null or undefined
            assertParamExists('callControllerCallPosesPreviewSetV1', 'setPosePreviewDto', setPosePreviewDto)
            const localVarPath = `/v1/call/poses.preview.set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPosePreviewDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksCreateV1: async (createStackParamsDto: CreateStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStackParamsDto' is not null or undefined
            assertParamExists('callControllerCallStacksCreateV1', 'createStackParamsDto', createStackParamsDto)
            const localVarPath = `/v1/call/stacks.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetStackParamsDto} getStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksGetV1: async (getStackParamsDto: GetStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStackParamsDto' is not null or undefined
            assertParamExists('callControllerCallStacksGetV1', 'getStackParamsDto', getStackParamsDto)
            const localVarPath = `/v1/call/stacks.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddItemsToStackParamsDto} addItemsToStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksItemsAddV1: async (addItemsToStackParamsDto: AddItemsToStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addItemsToStackParamsDto' is not null or undefined
            assertParamExists('callControllerCallStacksItemsAddV1', 'addItemsToStackParamsDto', addItemsToStackParamsDto)
            const localVarPath = `/v1/call/stacks.items.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveItemsFromStackParamsDto} removeItemsFromStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksItemsRemoveV1: async (removeItemsFromStackParamsDto: RemoveItemsFromStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeItemsFromStackParamsDto' is not null or undefined
            assertParamExists('callControllerCallStacksItemsRemoveV1', 'removeItemsFromStackParamsDto', removeItemsFromStackParamsDto)
            const localVarPath = `/v1/call/stacks.items.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListStacksParamsDto} listStacksParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksListV1: async (listStacksParamsDto: ListStacksParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listStacksParamsDto' is not null or undefined
            assertParamExists('callControllerCallStacksListV1', 'listStacksParamsDto', listStacksParamsDto)
            const localVarPath = `/v1/call/stacks.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listStacksParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksMetadataUpdateV1: async (updateResourceMetadataDto: UpdateResourceMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResourceMetadataDto' is not null or undefined
            assertParamExists('callControllerCallStacksMetadataUpdateV1', 'updateResourceMetadataDto', updateResourceMetadataDto)
            const localVarPath = `/v1/call/stacks.metadata.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageCreateV1: async (createStorageRecordParamsDto: CreateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStorageRecordParamsDto' is not null or undefined
            assertParamExists('callControllerCallStorageCreateV1', 'createStorageRecordParamsDto', createStorageRecordParamsDto)
            const localVarPath = `/v1/call/storage.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageDeleteV1: async (deleteStorageParamsDto: DeleteStorageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteStorageParamsDto' is not null or undefined
            assertParamExists('callControllerCallStorageDeleteV1', 'deleteStorageParamsDto', deleteStorageParamsDto)
            const localVarPath = `/v1/call/storage.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStorageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageGetManyV1: async (getStorageRecordParamsDto: GetStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStorageRecordParamsDto' is not null or undefined
            assertParamExists('callControllerCallStorageGetManyV1', 'getStorageRecordParamsDto', getStorageRecordParamsDto)
            const localVarPath = `/v1/call/storage.getMany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageUpdateV1: async (updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStorageRecordParamsDto' is not null or undefined
            assertParamExists('callControllerCallStorageUpdateV1', 'updateStorageRecordParamsDto', updateStorageRecordParamsDto)
            const localVarPath = `/v1/call/storage.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetVideosParamsDto} getVideosParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallVideosGetManyV1: async (getVideosParamsDto: GetVideosParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getVideosParamsDto' is not null or undefined
            assertParamExists('callControllerCallVideosGetManyV1', 'getVideosParamsDto', getVideosParamsDto)
            const localVarPath = `/v1/call/videos.getMany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getVideosParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetVideoParamsDto} getVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallVideosGetV1: async (getVideoParamsDto: GetVideoParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getVideoParamsDto' is not null or undefined
            assertParamExists('callControllerCallVideosGetV1', 'getVideoParamsDto', getVideoParamsDto)
            const localVarPath = `/v1/call/videos.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getVideoParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallApi - functional programming interface
 * @export
 */
export const CallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AttachAccessParamsDto} attachAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccessAttachV1(attachAccessParamsDto: AttachAccessParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccessAttachV1(attachAccessParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccessAttachV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ModifyAccessParamsDto} modifyAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccessGrantV1(modifyAccessParamsDto: ModifyAccessParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccessGrantV1(modifyAccessParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccessGrantV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddBalanceParamsDto} addBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsBalanceAddV1(addBalanceParamsDto: AddBalanceParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsBalanceAddV1(addBalanceParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsBalanceAddV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetBalanceParamsDto} getBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsBalanceGetV1(getBalanceParamsDto: GetBalanceParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsBalanceGetV1(getBalanceParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsBalanceGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsBalanceSelfV1(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsBalanceSelfV1(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsBalanceSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsCreateV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsCreateV1(createAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetAccountParamsDto} getAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsGetV1(getAccountParamsDto: GetAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsGetV1(getAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListAccountsParamsDto} listAccountsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsListV1(listAccountsParamsDto: ListAccountsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsListV1(listAccountsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallAccountsSelfV1(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallAccountsSelfV1(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallAccountsSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsCreateV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsCreateV1(createCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetCollectionParamsDto} getCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsGetV1(getCollectionParamsDto: GetCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsGetV1(getCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddItemsToCollectionParamsDto} addItemsToCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto: AddItemsToCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsItemsAddV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListCollectionItemsParamsDto} listCollectionItemsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto: ListCollectionItemsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionItemsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsItemsListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveItemsFromCollectionParamsDto} removeItemsFromCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto: RemoveItemsFromCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsItemsRemoveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListCollectionsParamsDto} listCollectionsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsListV1(listCollectionsParamsDto: ListCollectionsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsListV1(listCollectionsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallCollectionsMetadataUpdateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddAccountToGroupParamsDto} addAccountToGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto: AddAccountToGroupParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallGroupsAccountsAddV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveAccountFromGroupParamsDto} removeAccountFromGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto: RemoveAccountFromGroupParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallGroupsAccountsRemoveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallGroupsCreateV1(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallGroupsCreateV1(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallGroupsCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteParamsDto} deleteParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallGroupsDeleteV1(deleteParamsDto: DeleteParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallGroupsDeleteV1(deleteParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallGroupsDeleteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetGroupParamsDto} getGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallGroupsGetV1(getGroupParamsDto: GetGroupParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallGroupsGetV1(getGroupParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallGroupsGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageUrlResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallImagesGetManyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetImageParamsDto} getImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallImagesGetV1(getImageParamsDto: GetImageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallImagesGetV1(getImageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallImagesGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetImageRepresentationParamsDto} getImageRepresentationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto: GetImageRepresentationParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageRepresentationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallImagesRepresentationsGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsGetManyV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsGetManyV1(getOperationsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsGetManyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOperationParamsDto} getOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsGetV1(getOperationParamsDto: GetOperationParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsGetV1(getOperationParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListOperationsParamsDto} listOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsListV1(listOperationsParamsDto: ListOperationsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsListV1(listOperationsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsMetadataUpdateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateCreatomateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunAnimateCreatomateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateKling16ProV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunAnimateKling16ProV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateKling21V1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunAnimateKling21V1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunCompositeV1V1(compositeV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunCompositeV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContrastV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunContrastV1V1(contrastV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunContrastV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CropV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunCropV1V1(cropV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunCropV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CutV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunCutV1V1(cutV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunCutV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EchoV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunEchoV1V1(echoV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunEchoV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditFluxKontextDevV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunEditFluxKontextDevV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GptV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunGptV1V1(gptV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunGptV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GptV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunGptV2V1(gptV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunGptV2V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HauteLindaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunHauteLindaV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HauteNaomiV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunHauteNaomiV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagineKateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunImagineKateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InpaintKateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunInpaintKateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MathV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunMathV1V1(mathV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunMathV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NegateImageV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunNegateImageV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoiseV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunNoiseV1V1(noiseV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunNoiseV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectDetectionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunObjectDetectionV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnecompilerV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunOnecompilerV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineMapV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunPipelineMapV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoseEstimationV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunPoseEstimationV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResizeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunResizeV1V1(resizeV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunResizeV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentAnythingEmbeddingsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentAnythingMaskV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunSegmentAnythingMaskV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringsTemplateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunStringsTemplateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunTranslateV1V1(translateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunTranslateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpscaleV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunUpscaleV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VtonGiseleV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsRunVtonGiseleV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WaitOperationParamsDto} waitOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallOperationsWaitV1(waitOperationParamsDto: WaitOperationParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallOperationsWaitV1(waitOperationParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallOperationsWaitV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetPoseParamsDto} getPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallPosesGetV1(getPoseParamsDto: GetPoseParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallPosesGetV1(getPoseParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallPosesGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListPosesParamsDto} listPosesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallPosesListV1(listPosesParamsDto: ListPosesParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPosesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallPosesListV1(listPosesParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallPosesListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallPosesMetadataUpdateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetPosePreviewDto} setPosePreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallPosesPreviewSetV1(setPosePreviewDto: SetPosePreviewDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallPosesPreviewSetV1(setPosePreviewDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallPosesPreviewSetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksCreateV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksCreateV1(createStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetStackParamsDto} getStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksGetV1(getStackParamsDto: GetStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksGetV1(getStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddItemsToStackParamsDto} addItemsToStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksItemsAddV1(addItemsToStackParamsDto: AddItemsToStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksItemsAddV1(addItemsToStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksItemsAddV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveItemsFromStackParamsDto} removeItemsFromStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto: RemoveItemsFromStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksItemsRemoveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListStacksParamsDto} listStacksParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksListV1(listStacksParamsDto: ListStacksParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStacksDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksListV1(listStacksParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStacksMetadataUpdateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStorageCreateV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStorageCreateV1(createStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStorageCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStorageDeleteV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStorageDeleteV1(deleteStorageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStorageDeleteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStorageGetManyV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageRecordsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStorageGetManyV1(getStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStorageGetManyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallStorageUpdateV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallStorageUpdateV1(updateStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallStorageUpdateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetVideosParamsDto} getVideosParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallVideosGetManyV1(getVideosParamsDto: GetVideosParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VideoUrlResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallVideosGetManyV1(getVideosParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallVideosGetManyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetVideoParamsDto} getVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallVideosGetV1(getVideoParamsDto: GetVideoParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallVideosGetV1(getVideoParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallVideosGetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallApi - factory interface
 * @export
 */
export const CallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallApiFp(configuration)
    return {
        /**
         * 
         * @param {AttachAccessParamsDto} attachAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccessAttachV1(attachAccessParamsDto: AttachAccessParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallAccessAttachV1(attachAccessParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModifyAccessParamsDto} modifyAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccessGrantV1(modifyAccessParamsDto: ModifyAccessParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallAccessGrantV1(modifyAccessParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddBalanceParamsDto} addBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceAddV1(addBalanceParamsDto: AddBalanceParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallAccountsBalanceAddV1(addBalanceParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetBalanceParamsDto} getBalanceParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceGetV1(getBalanceParamsDto: GetBalanceParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.callControllerCallAccountsBalanceGetV1(getBalanceParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsBalanceSelfV1(body: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.callControllerCallAccountsBalanceSelfV1(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsCreateV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.callControllerCallAccountsCreateV1(createAccountParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAccountParamsDto} getAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsGetV1(getAccountParamsDto: GetAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.callControllerCallAccountsGetV1(getAccountParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListAccountsParamsDto} listAccountsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsListV1(listAccountsParamsDto: ListAccountsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsDto> {
            return localVarFp.callControllerCallAccountsListV1(listAccountsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallAccountsSelfV1(body: string, options?: RawAxiosRequestConfig): AxiosPromise<SelfAccountDto> {
            return localVarFp.callControllerCallAccountsSelfV1(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsCreateV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.callControllerCallCollectionsCreateV1(createCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetCollectionParamsDto} getCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsGetV1(getCollectionParamsDto: GetCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.callControllerCallCollectionsGetV1(getCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddItemsToCollectionParamsDto} addItemsToCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto: AddItemsToCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListCollectionItemsParamsDto} listCollectionItemsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto: ListCollectionItemsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionItemsDto> {
            return localVarFp.callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveItemsFromCollectionParamsDto} removeItemsFromCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto: RemoveItemsFromCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListCollectionsParamsDto} listCollectionsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsListV1(listCollectionsParamsDto: ListCollectionsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionsDto> {
            return localVarFp.callControllerCallCollectionsListV1(listCollectionsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddAccountToGroupParamsDto} addAccountToGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto: AddAccountToGroupParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveAccountFromGroupParamsDto} removeAccountFromGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto: RemoveAccountFromGroupParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsCreateV1(body: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.callControllerCallGroupsCreateV1(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteParamsDto} deleteParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsDeleteV1(deleteParamsDto: DeleteParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallGroupsDeleteV1(deleteParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetGroupParamsDto} getGroupParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallGroupsGetV1(getGroupParamsDto: GetGroupParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.callControllerCallGroupsGetV1(getGroupParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageUrlResponseDto>> {
            return localVarFp.callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetImageParamsDto} getImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesGetV1(getImageParamsDto: GetImageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.callControllerCallImagesGetV1(getImageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetImageRepresentationParamsDto} getImageRepresentationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto: GetImageRepresentationParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ImageRepresentationResponseDto> {
            return localVarFp.callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsGetManyV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<OperationEntity>> {
            return localVarFp.callControllerCallOperationsGetManyV1(getOperationsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOperationParamsDto} getOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsGetV1(getOperationParamsDto: GetOperationParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.callControllerCallOperationsGetV1(getOperationParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListOperationsParamsDto} listOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsListV1(listOperationsParamsDto: ListOperationsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListOperationsDto> {
            return localVarFp.callControllerCallOperationsListV1(listOperationsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateCreatomateV1Response> {
            return localVarFp.callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateKling16ProV1Response> {
            return localVarFp.callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateKling21V1Response> {
            return localVarFp.callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CompositeV1Response> {
            return localVarFp.callControllerCallOperationsRunCompositeV1V1(compositeV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ContrastV1Response> {
            return localVarFp.callControllerCallOperationsRunContrastV1V1(contrastV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CropV1Response> {
            return localVarFp.callControllerCallOperationsRunCropV1V1(cropV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CutV1Response> {
            return localVarFp.callControllerCallOperationsRunCutV1V1(cutV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EchoV1Response> {
            return localVarFp.callControllerCallOperationsRunEchoV1V1(echoV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EditFluxKontextDevV1Response> {
            return localVarFp.callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GptV1Response> {
            return localVarFp.callControllerCallOperationsRunGptV1V1(gptV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GptV2Response> {
            return localVarFp.callControllerCallOperationsRunGptV2V1(gptV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig): AxiosPromise<HauteLindaV1Response> {
            return localVarFp.callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig): AxiosPromise<HauteNaomiV1Response> {
            return localVarFp.callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ImagineKateV1Response> {
            return localVarFp.callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<InpaintKateV1Response> {
            return localVarFp.callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MathV1Response> {
            return localVarFp.callControllerCallOperationsRunMathV1V1(mathV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<NegateImageV1Response> {
            return localVarFp.callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig): AxiosPromise<NoiseV1Response> {
            return localVarFp.callControllerCallOperationsRunNoiseV1V1(noiseV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ObjectDetectionV1Response> {
            return localVarFp.callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OnecompilerV1Response> {
            return localVarFp.callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PipelineMapV1Response> {
            return localVarFp.callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PoseEstimationV1Response> {
            return localVarFp.callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ResizeV1Response> {
            return localVarFp.callControllerCallOperationsRunResizeV1V1(resizeV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<SegmentAnythingEmbeddingsV1Response> {
            return localVarFp.callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<SegmentAnythingMaskV1Response> {
            return localVarFp.callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<StringsTemplateV1Response> {
            return localVarFp.callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<TranslateV1Response> {
            return localVarFp.callControllerCallOperationsRunTranslateV1V1(translateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpscaleV1Response> {
            return localVarFp.callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<VtonGiseleV1Response> {
            return localVarFp.callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WaitOperationParamsDto} waitOperationParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallOperationsWaitV1(waitOperationParamsDto: WaitOperationParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.callControllerCallOperationsWaitV1(waitOperationParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetPoseParamsDto} getPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesGetV1(getPoseParamsDto: GetPoseParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<PoseEntity> {
            return localVarFp.callControllerCallPosesGetV1(getPoseParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListPosesParamsDto} listPosesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesListV1(listPosesParamsDto: ListPosesParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListPosesDto> {
            return localVarFp.callControllerCallPosesListV1(listPosesParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPosePreviewDto} setPosePreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallPosesPreviewSetV1(setPosePreviewDto: SetPosePreviewDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallPosesPreviewSetV1(setPosePreviewDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksCreateV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.callControllerCallStacksCreateV1(createStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetStackParamsDto} getStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksGetV1(getStackParamsDto: GetStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.callControllerCallStacksGetV1(getStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddItemsToStackParamsDto} addItemsToStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksItemsAddV1(addItemsToStackParamsDto: AddItemsToStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.callControllerCallStacksItemsAddV1(addItemsToStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveItemsFromStackParamsDto} removeItemsFromStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto: RemoveItemsFromStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListStacksParamsDto} listStacksParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksListV1(listStacksParamsDto: ListStacksParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ListStacksDto> {
            return localVarFp.callControllerCallStacksListV1(listStacksParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageCreateV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.callControllerCallStorageCreateV1(createStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageDeleteV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callControllerCallStorageDeleteV1(deleteStorageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageGetManyV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageRecordsResultDto>> {
            return localVarFp.callControllerCallStorageGetManyV1(getStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallStorageUpdateV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.callControllerCallStorageUpdateV1(updateStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetVideosParamsDto} getVideosParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallVideosGetManyV1(getVideosParamsDto: GetVideosParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<VideoUrlResponseDto>> {
            return localVarFp.callControllerCallVideosGetManyV1(getVideosParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetVideoParamsDto} getVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallVideosGetV1(getVideoParamsDto: GetVideoParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<VideoEntity> {
            return localVarFp.callControllerCallVideosGetV1(getVideoParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallApi - object-oriented interface
 * @export
 * @class CallApi
 * @extends {BaseAPI}
 */
export class CallApi extends BaseAPI {
    /**
     * 
     * @param {AttachAccessParamsDto} attachAccessParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccessAttachV1(attachAccessParamsDto: AttachAccessParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccessAttachV1(attachAccessParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModifyAccessParamsDto} modifyAccessParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccessGrantV1(modifyAccessParamsDto: ModifyAccessParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccessGrantV1(modifyAccessParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddBalanceParamsDto} addBalanceParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsBalanceAddV1(addBalanceParamsDto: AddBalanceParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsBalanceAddV1(addBalanceParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetBalanceParamsDto} getBalanceParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsBalanceGetV1(getBalanceParamsDto: GetBalanceParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsBalanceGetV1(getBalanceParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsBalanceSelfV1(body: string, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsBalanceSelfV1(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAccountParamsDto} createAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsCreateV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsCreateV1(createAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAccountParamsDto} getAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsGetV1(getAccountParamsDto: GetAccountParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsGetV1(getAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListAccountsParamsDto} listAccountsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsListV1(listAccountsParamsDto: ListAccountsParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsListV1(listAccountsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallAccountsSelfV1(body: string, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallAccountsSelfV1(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionParamsDto} createCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsCreateV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsCreateV1(createCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetCollectionParamsDto} getCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsGetV1(getCollectionParamsDto: GetCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsGetV1(getCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddItemsToCollectionParamsDto} addItemsToCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto: AddItemsToCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsItemsAddV1(addItemsToCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListCollectionItemsParamsDto} listCollectionItemsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto: ListCollectionItemsParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsItemsListV1(listCollectionItemsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveItemsFromCollectionParamsDto} removeItemsFromCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto: RemoveItemsFromCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsItemsRemoveV1(removeItemsFromCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListCollectionsParamsDto} listCollectionsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsListV1(listCollectionsParamsDto: ListCollectionsParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsListV1(listCollectionsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallCollectionsMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddAccountToGroupParamsDto} addAccountToGroupParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto: AddAccountToGroupParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallGroupsAccountsAddV1(addAccountToGroupParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveAccountFromGroupParamsDto} removeAccountFromGroupParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto: RemoveAccountFromGroupParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallGroupsAccountsRemoveV1(removeAccountFromGroupParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallGroupsCreateV1(body: string, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallGroupsCreateV1(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteParamsDto} deleteParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallGroupsDeleteV1(deleteParamsDto: DeleteParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallGroupsDeleteV1(deleteParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetGroupParamsDto} getGroupParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallGroupsGetV1(getGroupParamsDto: GetGroupParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallGroupsGetV1(getGroupParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallImagesGetManyV1(getUrlsForImagesParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetImageParamsDto} getImageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallImagesGetV1(getImageParamsDto: GetImageParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallImagesGetV1(getImageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetImageRepresentationParamsDto} getImageRepresentationParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto: GetImageRepresentationParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallImagesRepresentationsGetV1(getImageRepresentationParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOperationsParamsDto} getOperationsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsGetManyV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsGetManyV1(getOperationsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOperationParamsDto} getOperationParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsGetV1(getOperationParamsDto: GetOperationParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsGetV1(getOperationParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListOperationsParamsDto} listOperationsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsListV1(listOperationsParamsDto: ListOperationsParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsListV1(listOperationsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunAnimateCreatomateV1V1(animateCreatomateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunAnimateKling16ProV1V1(animateKling16ProV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateKling21V1Request} animateKling21V1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunAnimateKling21V1V1(animateKling21V1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompositeV1Request} compositeV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunCompositeV1V1(compositeV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ContrastV1Request} contrastV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunContrastV1V1(contrastV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CropV1Request} cropV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunCropV1V1(cropV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CutV1Request} cutV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunCutV1V1(cutV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EchoV1Request} echoV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunEchoV1V1(echoV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GptV1Request} gptV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunGptV1V1(gptV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GptV2Request} gptV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunGptV2V1(gptV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HauteLindaV1Request} hauteLindaV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunHauteLindaV1V1(hauteLindaV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HauteNaomiV1Request} hauteNaomiV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunHauteNaomiV1V1(hauteNaomiV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImagineKateV1Request} imagineKateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunImagineKateV1V1(imagineKateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InpaintKateV1Request} inpaintKateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunInpaintKateV1V1(inpaintKateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MathV1Request} mathV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunMathV1V1(mathV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NegateImageV1Request} negateImageV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunNegateImageV1V1(negateImageV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NoiseV1Request} noiseV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunNoiseV1V1(noiseV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ObjectDetectionV1Request} objectDetectionV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunObjectDetectionV1V1(objectDetectionV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OnecompilerV1Request} onecompilerV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunOnecompilerV1V1(onecompilerV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PipelineMapV1Request} pipelineMapV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunPipelineMapV1V1(pipelineMapV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PoseEstimationV1Request} poseEstimationV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunPoseEstimationV1V1(poseEstimationV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResizeV1Request} resizeV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunResizeV1V1(resizeV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StringsTemplateV1Request} stringsTemplateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunStringsTemplateV1V1(stringsTemplateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TranslateV1Request} translateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunTranslateV1V1(translateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpscaleV1Request} upscaleV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunUpscaleV1V1(upscaleV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VtonGiseleV1Request} vtonGiseleV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsRunVtonGiseleV1V1(vtonGiseleV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WaitOperationParamsDto} waitOperationParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallOperationsWaitV1(waitOperationParamsDto: WaitOperationParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallOperationsWaitV1(waitOperationParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetPoseParamsDto} getPoseParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallPosesGetV1(getPoseParamsDto: GetPoseParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallPosesGetV1(getPoseParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListPosesParamsDto} listPosesParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallPosesListV1(listPosesParamsDto: ListPosesParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallPosesListV1(listPosesParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallPosesMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPosePreviewDto} setPosePreviewDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallPosesPreviewSetV1(setPosePreviewDto: SetPosePreviewDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallPosesPreviewSetV1(setPosePreviewDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStackParamsDto} createStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksCreateV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksCreateV1(createStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetStackParamsDto} getStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksGetV1(getStackParamsDto: GetStackParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksGetV1(getStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddItemsToStackParamsDto} addItemsToStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksItemsAddV1(addItemsToStackParamsDto: AddItemsToStackParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksItemsAddV1(addItemsToStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveItemsFromStackParamsDto} removeItemsFromStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto: RemoveItemsFromStackParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksItemsRemoveV1(removeItemsFromStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListStacksParamsDto} listStacksParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksListV1(listStacksParamsDto: ListStacksParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksListV1(listStacksParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateResourceMetadataDto} updateResourceMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto: UpdateResourceMetadataDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStacksMetadataUpdateV1(updateResourceMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStorageCreateV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStorageCreateV1(createStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStorageDeleteV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStorageDeleteV1(deleteStorageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStorageGetManyV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStorageGetManyV1(getStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallStorageUpdateV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallStorageUpdateV1(updateStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetVideosParamsDto} getVideosParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallVideosGetManyV1(getVideosParamsDto: GetVideosParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallVideosGetManyV1(getVideosParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetVideoParamsDto} getVideoParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallVideosGetV1(getVideoParamsDto: GetVideoParamsDto, options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallVideosGetV1(getVideoParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1: async (id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'id', id)
            // verify required parameter 'addItemsToCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'addItemsToCollectionControllerParamsDto', addItemsToCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1: async (createCollectionParamsDto: CreateCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCollectionParamsDto' is not null or undefined
            assertParamExists('collectionsControllerCreateCollectionV1', 'createCollectionParamsDto', createCollectionParamsDto)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerGetCollectionV1', 'id', id)
            const localVarPath = `/v1/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1: async (orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1: async (id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerListItemsV1', 'id', id)
            const localVarPath = `/v1/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1: async (id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'id', id)
            // verify required parameter 'removeItemsFromCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'removeItemsFromCollectionControllerParamsDto', removeItemsFromCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/collections/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerAddItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerCreateCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerGetCollectionV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerGetCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListCollectionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionItemsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerRemoveItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerGetCollectionV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionsDto> {
            return localVarFp.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionItemsDto> {
            return localVarFp.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionParamsDto} createCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerGetCollectionV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [cursor] 
     * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CollectionsControllerListCollectionsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListCollectionsV1OrderByEnum = typeof CollectionsControllerListCollectionsV1OrderByEnum[keyof typeof CollectionsControllerListCollectionsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListItemsV1OrderByEnum = typeof CollectionsControllerListItemsV1OrderByEnum[keyof typeof CollectionsControllerListItemsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1KindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Video: 'video',
    Pose: 'pose',
    Storage: 'storage',
    Pipeline: 'pipeline',
    Workflow: 'workflow'
} as const;
export type CollectionsControllerListItemsV1KindEnum = typeof CollectionsControllerListItemsV1KindEnum[keyof typeof CollectionsControllerListItemsV1KindEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1: async (id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'id', id)
            // verify required parameter 'addAccountToGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'addAccountToGroupControllerParamsDto', addAccountToGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountToGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerDeleteGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerGetGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1: async (id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'id', id)
            // verify required parameter 'removeAccountFromGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'removeAccountFromGroupControllerParamsDto', removeAccountFromGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountFromGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerAddAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerCreateGroupV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerCreateGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerDeleteGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerDeleteGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerGetGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerGetGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerRemoveAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerCreateGroupV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerDeleteGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerGetGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerCreateGroupV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerDeleteGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerGetGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1: async (createImageParamsDto: CreateImageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createImageParamsDto' is not null or undefined
            assertParamExists('imagesControllerFinalizeUploadV1', 'createImageParamsDto', createImageParamsDto)
            const localVarPath = `/v1/images/upload/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetImageV1', 'id', id)
            const localVarPath = `/v1/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetRepresentationV1: async (id: string, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetRepresentationV1', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('imagesControllerGetRepresentationV1', 'type', type)
            const localVarPath = `/v1/images/{id}/representation/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1: async (getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUrlsForImagesParamsDto' is not null or undefined
            assertParamExists('imagesControllerGetUrlsV1', 'getUrlsForImagesParamsDto', getUrlsForImagesParamsDto)
            const localVarPath = `/v1/images/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUrlsForImagesParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/images/upload/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerFinalizeUploadV1(createImageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerFinalizeUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageRepresentationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetRepresentationV1(id, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetRepresentationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetUrlsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializeImageUploadResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerStartUploadV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerStartUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerGetImageV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageRepresentationResponseDto> {
            return localVarFp.imagesControllerGetRepresentationV1(id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageEntity>> {
            return localVarFp.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): AxiosPromise<InitializeImageUploadResultDto> {
            return localVarFp.imagesControllerStartUploadV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @param {CreateImageParamsDto} createImageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetRepresentationV1(id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerStartUploadV1(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerStartUploadV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerGetOperationV1', 'id', id)
            const localVarPath = `/v1/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1: async (getOperationsParamsDto: GetOperationsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOperationsParamsDto' is not null or undefined
            assertParamExists('operationsControllerGetOperationsV1', 'getOperationsParamsDto', getOperationsParamsDto)
            const localVarPath = `/v1/operations/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOperationsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1: async (orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateCreatomateV1V1: async (animateCreatomateV1Request: AnimateCreatomateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateCreatomateV1Request' is not null or undefined
            assertParamExists('operationsControllerRunAnimateCreatomateV1V1', 'animateCreatomateV1Request', animateCreatomateV1Request)
            const localVarPath = `/v1/operations/run/animate.creatomate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateCreatomateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateKling16ProV1V1: async (animateKling16ProV1Request: AnimateKling16ProV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateKling16ProV1Request' is not null or undefined
            assertParamExists('operationsControllerRunAnimateKling16ProV1V1', 'animateKling16ProV1Request', animateKling16ProV1Request)
            const localVarPath = `/v1/operations/run/animate.kling_1_6_pro.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateKling16ProV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateKling21V1V1: async (animateKling21V1Request: AnimateKling21V1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'animateKling21V1Request' is not null or undefined
            assertParamExists('operationsControllerRunAnimateKling21V1V1', 'animateKling21V1Request', animateKling21V1Request)
            const localVarPath = `/v1/operations/run/animate.kling_2_1.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(animateKling21V1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCompositeV1V1: async (compositeV1Request: CompositeV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeV1Request' is not null or undefined
            assertParamExists('operationsControllerRunCompositeV1V1', 'compositeV1Request', compositeV1Request)
            const localVarPath = `/v1/operations/run/composite.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compositeV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunContrastV1V1: async (contrastV1Request: ContrastV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contrastV1Request' is not null or undefined
            assertParamExists('operationsControllerRunContrastV1V1', 'contrastV1Request', contrastV1Request)
            const localVarPath = `/v1/operations/run/contrast.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contrastV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCropV1V1: async (cropV1Request: CropV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cropV1Request' is not null or undefined
            assertParamExists('operationsControllerRunCropV1V1', 'cropV1Request', cropV1Request)
            const localVarPath = `/v1/operations/run/crop.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cropV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCutV1V1: async (cutV1Request: CutV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cutV1Request' is not null or undefined
            assertParamExists('operationsControllerRunCutV1V1', 'cutV1Request', cutV1Request)
            const localVarPath = `/v1/operations/run/cut.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cutV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunEchoV1V1: async (echoV1Request: EchoV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'echoV1Request' is not null or undefined
            assertParamExists('operationsControllerRunEchoV1V1', 'echoV1Request', echoV1Request)
            const localVarPath = `/v1/operations/run/echo.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(echoV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunEditFluxKontextDevV1V1: async (editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editFluxKontextDevV1Request' is not null or undefined
            assertParamExists('operationsControllerRunEditFluxKontextDevV1V1', 'editFluxKontextDevV1Request', editFluxKontextDevV1Request)
            const localVarPath = `/v1/operations/run/edit.flux_kontext_dev.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editFluxKontextDevV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV1V1: async (gptV1Request: GptV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gptV1Request' is not null or undefined
            assertParamExists('operationsControllerRunGptV1V1', 'gptV1Request', gptV1Request)
            const localVarPath = `/v1/operations/run/gpt.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gptV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV2V1: async (gptV2Request: GptV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gptV2Request' is not null or undefined
            assertParamExists('operationsControllerRunGptV2V1', 'gptV2Request', gptV2Request)
            const localVarPath = `/v1/operations/run/gpt.v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gptV2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunHauteLindaV1V1: async (hauteLindaV1Request: HauteLindaV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hauteLindaV1Request' is not null or undefined
            assertParamExists('operationsControllerRunHauteLindaV1V1', 'hauteLindaV1Request', hauteLindaV1Request)
            const localVarPath = `/v1/operations/run/haute.linda.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hauteLindaV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunHauteNaomiV1V1: async (hauteNaomiV1Request: HauteNaomiV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hauteNaomiV1Request' is not null or undefined
            assertParamExists('operationsControllerRunHauteNaomiV1V1', 'hauteNaomiV1Request', hauteNaomiV1Request)
            const localVarPath = `/v1/operations/run/haute.naomi.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hauteNaomiV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunImagineKateV1V1: async (imagineKateV1Request: ImagineKateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagineKateV1Request' is not null or undefined
            assertParamExists('operationsControllerRunImagineKateV1V1', 'imagineKateV1Request', imagineKateV1Request)
            const localVarPath = `/v1/operations/run/imagine.kate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagineKateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunInpaintKateV1V1: async (inpaintKateV1Request: InpaintKateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inpaintKateV1Request' is not null or undefined
            assertParamExists('operationsControllerRunInpaintKateV1V1', 'inpaintKateV1Request', inpaintKateV1Request)
            const localVarPath = `/v1/operations/run/inpaint.kate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inpaintKateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunMathV1V1: async (mathV1Request: MathV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mathV1Request' is not null or undefined
            assertParamExists('operationsControllerRunMathV1V1', 'mathV1Request', mathV1Request)
            const localVarPath = `/v1/operations/run/math.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mathV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunNegateImageV1V1: async (negateImageV1Request: NegateImageV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'negateImageV1Request' is not null or undefined
            assertParamExists('operationsControllerRunNegateImageV1V1', 'negateImageV1Request', negateImageV1Request)
            const localVarPath = `/v1/operations/run/negateImage.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(negateImageV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunNoiseV1V1: async (noiseV1Request: NoiseV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noiseV1Request' is not null or undefined
            assertParamExists('operationsControllerRunNoiseV1V1', 'noiseV1Request', noiseV1Request)
            const localVarPath = `/v1/operations/run/noise.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noiseV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunObjectDetectionV1V1: async (objectDetectionV1Request: ObjectDetectionV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectDetectionV1Request' is not null or undefined
            assertParamExists('operationsControllerRunObjectDetectionV1V1', 'objectDetectionV1Request', objectDetectionV1Request)
            const localVarPath = `/v1/operations/run/objectDetection.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectDetectionV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunOnecompilerV1V1: async (onecompilerV1Request: OnecompilerV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'onecompilerV1Request' is not null or undefined
            assertParamExists('operationsControllerRunOnecompilerV1V1', 'onecompilerV1Request', onecompilerV1Request)
            const localVarPath = `/v1/operations/run/onecompiler.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onecompilerV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPipelineMapV1V1: async (pipelineMapV1Request: PipelineMapV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineMapV1Request' is not null or undefined
            assertParamExists('operationsControllerRunPipelineMapV1V1', 'pipelineMapV1Request', pipelineMapV1Request)
            const localVarPath = `/v1/operations/run/pipelineMap.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineMapV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPoseEstimationV1V1: async (poseEstimationV1Request: PoseEstimationV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poseEstimationV1Request' is not null or undefined
            assertParamExists('operationsControllerRunPoseEstimationV1V1', 'poseEstimationV1Request', poseEstimationV1Request)
            const localVarPath = `/v1/operations/run/poseEstimation.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(poseEstimationV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunResizeV1V1: async (resizeV1Request: ResizeV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resizeV1Request' is not null or undefined
            assertParamExists('operationsControllerRunResizeV1V1', 'resizeV1Request', resizeV1Request)
            const localVarPath = `/v1/operations/run/resize.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resizeV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingEmbeddingsV1V1: async (segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentAnythingEmbeddingsV1Request' is not null or undefined
            assertParamExists('operationsControllerRunSegmentAnythingEmbeddingsV1V1', 'segmentAnythingEmbeddingsV1Request', segmentAnythingEmbeddingsV1Request)
            const localVarPath = `/v1/operations/run/segmentAnything.embeddings.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentAnythingEmbeddingsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingMaskV1V1: async (segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentAnythingMaskV1Request' is not null or undefined
            assertParamExists('operationsControllerRunSegmentAnythingMaskV1V1', 'segmentAnythingMaskV1Request', segmentAnythingMaskV1Request)
            const localVarPath = `/v1/operations/run/segmentAnything.mask.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentAnythingMaskV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunStringsTemplateV1V1: async (stringsTemplateV1Request: StringsTemplateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stringsTemplateV1Request' is not null or undefined
            assertParamExists('operationsControllerRunStringsTemplateV1V1', 'stringsTemplateV1Request', stringsTemplateV1Request)
            const localVarPath = `/v1/operations/run/strings.template.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stringsTemplateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunTranslateV1V1: async (translateV1Request: TranslateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translateV1Request' is not null or undefined
            assertParamExists('operationsControllerRunTranslateV1V1', 'translateV1Request', translateV1Request)
            const localVarPath = `/v1/operations/run/translate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunUpscaleV1V1: async (upscaleV1Request: UpscaleV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upscaleV1Request' is not null or undefined
            assertParamExists('operationsControllerRunUpscaleV1V1', 'upscaleV1Request', upscaleV1Request)
            const localVarPath = `/v1/operations/run/upscale.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upscaleV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunVtonGiseleV1V1: async (vtonGiseleV1Request: VtonGiseleV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vtonGiseleV1Request' is not null or undefined
            assertParamExists('operationsControllerRunVtonGiseleV1V1', 'vtonGiseleV1Request', vtonGiseleV1Request)
            const localVarPath = `/v1/operations/run/vton.gisele.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vtonGiseleV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/operations/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationsV1(getOperationsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerListOperationsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerListOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateCreatomateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunAnimateCreatomateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateKling16ProV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunAnimateKling16ProV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimateKling21V1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunAnimateKling21V1V1(animateKling21V1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunAnimateKling21V1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunCompositeV1V1(compositeV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunCompositeV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContrastV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunContrastV1V1(contrastV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunContrastV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CropV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunCropV1V1(cropV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunCropV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CutV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunCutV1V1(cutV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunCutV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EchoV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunEchoV1V1(echoV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunEchoV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditFluxKontextDevV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunEditFluxKontextDevV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GptV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunGptV1V1(gptV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunGptV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GptV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunGptV2V1(gptV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunGptV2V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HauteLindaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunHauteLindaV1V1(hauteLindaV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunHauteLindaV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HauteNaomiV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunHauteNaomiV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagineKateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunImagineKateV1V1(imagineKateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunImagineKateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InpaintKateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunInpaintKateV1V1(inpaintKateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunInpaintKateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MathV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunMathV1V1(mathV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunMathV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NegateImageV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunNegateImageV1V1(negateImageV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunNegateImageV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoiseV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunNoiseV1V1(noiseV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunNoiseV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectDetectionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunObjectDetectionV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnecompilerV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunOnecompilerV1V1(onecompilerV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunOnecompilerV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineMapV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunPipelineMapV1V1(pipelineMapV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunPipelineMapV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoseEstimationV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunPoseEstimationV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResizeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunResizeV1V1(resizeV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunResizeV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentAnythingEmbeddingsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunSegmentAnythingEmbeddingsV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentAnythingMaskV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunSegmentAnythingMaskV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringsTemplateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunStringsTemplateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunTranslateV1V1(translateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunTranslateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpscaleV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunUpscaleV1V1(upscaleV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunUpscaleV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VtonGiseleV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunVtonGiseleV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerGetOperationV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<OperationEntity>> {
            return localVarFp.operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOperationsDto> {
            return localVarFp.operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateCreatomateV1Response> {
            return localVarFp.operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateKling16ProV1Response> {
            return localVarFp.operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnimateKling21V1Request} animateKling21V1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig): AxiosPromise<AnimateKling21V1Response> {
            return localVarFp.operationsControllerRunAnimateKling21V1V1(animateKling21V1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompositeV1Request} compositeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CompositeV1Response> {
            return localVarFp.operationsControllerRunCompositeV1V1(compositeV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ContrastV1Request} contrastV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ContrastV1Response> {
            return localVarFp.operationsControllerRunContrastV1V1(contrastV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CropV1Request} cropV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CropV1Response> {
            return localVarFp.operationsControllerRunCropV1V1(cropV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CutV1Request} cutV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CutV1Response> {
            return localVarFp.operationsControllerRunCutV1V1(cutV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EchoV1Request} echoV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EchoV1Response> {
            return localVarFp.operationsControllerRunEchoV1V1(echoV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EditFluxKontextDevV1Response> {
            return localVarFp.operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GptV1Request} gptV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GptV1Response> {
            return localVarFp.operationsControllerRunGptV1V1(gptV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GptV2Request} gptV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GptV2Response> {
            return localVarFp.operationsControllerRunGptV2V1(gptV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HauteLindaV1Request} hauteLindaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig): AxiosPromise<HauteLindaV1Response> {
            return localVarFp.operationsControllerRunHauteLindaV1V1(hauteLindaV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HauteNaomiV1Request} hauteNaomiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig): AxiosPromise<HauteNaomiV1Response> {
            return localVarFp.operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImagineKateV1Request} imagineKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ImagineKateV1Response> {
            return localVarFp.operationsControllerRunImagineKateV1V1(imagineKateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InpaintKateV1Request} inpaintKateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<InpaintKateV1Response> {
            return localVarFp.operationsControllerRunInpaintKateV1V1(inpaintKateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MathV1Request} mathV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MathV1Response> {
            return localVarFp.operationsControllerRunMathV1V1(mathV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NegateImageV1Request} negateImageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<NegateImageV1Response> {
            return localVarFp.operationsControllerRunNegateImageV1V1(negateImageV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NoiseV1Request} noiseV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig): AxiosPromise<NoiseV1Response> {
            return localVarFp.operationsControllerRunNoiseV1V1(noiseV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ObjectDetectionV1Request} objectDetectionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ObjectDetectionV1Response> {
            return localVarFp.operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OnecompilerV1Request} onecompilerV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OnecompilerV1Response> {
            return localVarFp.operationsControllerRunOnecompilerV1V1(onecompilerV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PipelineMapV1Request} pipelineMapV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PipelineMapV1Response> {
            return localVarFp.operationsControllerRunPipelineMapV1V1(pipelineMapV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PoseEstimationV1Request} poseEstimationV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PoseEstimationV1Response> {
            return localVarFp.operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResizeV1Request} resizeV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<ResizeV1Response> {
            return localVarFp.operationsControllerRunResizeV1V1(resizeV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<SegmentAnythingEmbeddingsV1Response> {
            return localVarFp.operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<SegmentAnythingMaskV1Response> {
            return localVarFp.operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StringsTemplateV1Request} stringsTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<StringsTemplateV1Response> {
            return localVarFp.operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TranslateV1Request} translateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<TranslateV1Response> {
            return localVarFp.operationsControllerRunTranslateV1V1(translateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpscaleV1Request} upscaleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpscaleV1Response> {
            return localVarFp.operationsControllerRunUpscaleV1V1(upscaleV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VtonGiseleV1Request} vtonGiseleV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<VtonGiseleV1Response> {
            return localVarFp.operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOperationsParamsDto} getOperationsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateCreatomateV1Request} animateCreatomateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request: AnimateCreatomateV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunAnimateCreatomateV1V1(animateCreatomateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateKling16ProV1Request} animateKling16ProV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request: AnimateKling16ProV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunAnimateKling16ProV1V1(animateKling16ProV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnimateKling21V1Request} animateKling21V1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunAnimateKling21V1V1(animateKling21V1Request: AnimateKling21V1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunAnimateKling21V1V1(animateKling21V1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompositeV1Request} compositeV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunCompositeV1V1(compositeV1Request: CompositeV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunCompositeV1V1(compositeV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ContrastV1Request} contrastV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunContrastV1V1(contrastV1Request: ContrastV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunContrastV1V1(contrastV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CropV1Request} cropV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunCropV1V1(cropV1Request: CropV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunCropV1V1(cropV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CutV1Request} cutV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunCutV1V1(cutV1Request: CutV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunCutV1V1(cutV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EchoV1Request} echoV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunEchoV1V1(echoV1Request: EchoV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunEchoV1V1(echoV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditFluxKontextDevV1Request} editFluxKontextDevV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request: EditFluxKontextDevV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunEditFluxKontextDevV1V1(editFluxKontextDevV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GptV1Request} gptV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunGptV1V1(gptV1Request: GptV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunGptV1V1(gptV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GptV2Request} gptV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunGptV2V1(gptV2Request: GptV2Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunGptV2V1(gptV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HauteLindaV1Request} hauteLindaV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunHauteLindaV1V1(hauteLindaV1Request: HauteLindaV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunHauteLindaV1V1(hauteLindaV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HauteNaomiV1Request} hauteNaomiV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request: HauteNaomiV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunHauteNaomiV1V1(hauteNaomiV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImagineKateV1Request} imagineKateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunImagineKateV1V1(imagineKateV1Request: ImagineKateV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunImagineKateV1V1(imagineKateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InpaintKateV1Request} inpaintKateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunInpaintKateV1V1(inpaintKateV1Request: InpaintKateV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunInpaintKateV1V1(inpaintKateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MathV1Request} mathV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunMathV1V1(mathV1Request: MathV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunMathV1V1(mathV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NegateImageV1Request} negateImageV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunNegateImageV1V1(negateImageV1Request: NegateImageV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunNegateImageV1V1(negateImageV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NoiseV1Request} noiseV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunNoiseV1V1(noiseV1Request: NoiseV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunNoiseV1V1(noiseV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ObjectDetectionV1Request} objectDetectionV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request: ObjectDetectionV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunObjectDetectionV1V1(objectDetectionV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OnecompilerV1Request} onecompilerV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunOnecompilerV1V1(onecompilerV1Request: OnecompilerV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunOnecompilerV1V1(onecompilerV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PipelineMapV1Request} pipelineMapV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunPipelineMapV1V1(pipelineMapV1Request: PipelineMapV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunPipelineMapV1V1(pipelineMapV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PoseEstimationV1Request} poseEstimationV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request: PoseEstimationV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunPoseEstimationV1V1(poseEstimationV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResizeV1Request} resizeV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunResizeV1V1(resizeV1Request: ResizeV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunResizeV1V1(resizeV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentAnythingEmbeddingsV1Request} segmentAnythingEmbeddingsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request: SegmentAnythingEmbeddingsV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentAnythingMaskV1Request} segmentAnythingMaskV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request: SegmentAnythingMaskV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunSegmentAnythingMaskV1V1(segmentAnythingMaskV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StringsTemplateV1Request} stringsTemplateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request: StringsTemplateV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunStringsTemplateV1V1(stringsTemplateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TranslateV1Request} translateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunTranslateV1V1(translateV1Request: TranslateV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunTranslateV1V1(translateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpscaleV1Request} upscaleV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunUpscaleV1V1(upscaleV1Request: UpscaleV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunUpscaleV1V1(upscaleV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VtonGiseleV1Request} vtonGiseleV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request: VtonGiseleV1Request, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunVtonGiseleV1V1(vtonGiseleV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OperationsControllerListOperationsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type OperationsControllerListOperationsV1OrderByEnum = typeof OperationsControllerListOperationsV1OrderByEnum[keyof typeof OperationsControllerListOperationsV1OrderByEnum];


/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerListAvailablePermissionsV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/permissions/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerListAvailablePermissionsV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerListAvailablePermissionsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerListAvailablePermissionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerListAvailablePermissionsV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.permissionsControllerListAvailablePermissionsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerListAvailablePermissionsV1(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerListAvailablePermissionsV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1: async (createPipelineParamsDto: CreatePipelineParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPipelineParamsDto' is not null or undefined
            assertParamExists('pipelinesControllerCreatePipelineV1', 'createPipelineParamsDto', createPipelineParamsDto)
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPipelineParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesControllerGetPipelineV1', 'id', id)
            const localVarPath = `/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PipelinesControllerListPipelinesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [parentOperationId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1: async (orderBy?: PipelinesControllerListPipelinesV1OrderByEnum, limit?: number, parentOperationId?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (parentOperationId !== undefined) {
                localVarQueryParameter['parentOperationId'] = parentOperationId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerCreatePipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerGetPipelineV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerGetPipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PipelinesControllerListPipelinesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [parentOperationId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerListPipelinesV1(orderBy?: PipelinesControllerListPipelinesV1OrderByEnum, limit?: number, parentOperationId?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPipelinesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerListPipelinesV1(orderBy, limit, parentOperationId, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerListPipelinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto> {
            return localVarFp.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto> {
            return localVarFp.pipelinesControllerGetPipelineV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PipelinesControllerListPipelinesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [parentOperationId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1(orderBy?: PipelinesControllerListPipelinesV1OrderByEnum, limit?: number, parentOperationId?: string, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPipelinesDto> {
            return localVarFp.pipelinesControllerListPipelinesV1(orderBy, limit, parentOperationId, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @param {CreatePipelineParamsDto} createPipelineParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerGetPipelineV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PipelinesControllerListPipelinesV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [parentOperationId] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerListPipelinesV1(orderBy?: PipelinesControllerListPipelinesV1OrderByEnum, limit?: number, parentOperationId?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerListPipelinesV1(orderBy, limit, parentOperationId, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PipelinesControllerListPipelinesV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC'
} as const;
export type PipelinesControllerListPipelinesV1OrderByEnum = typeof PipelinesControllerListPipelinesV1OrderByEnum[keyof typeof PipelinesControllerListPipelinesV1OrderByEnum];


/**
 * PosesApi - axios parameter creator
 * @export
 */
export const PosesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posesControllerGetPoseV1', 'id', id)
            const localVarPath = `/v1/poses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListPosesV1: async (orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/poses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SetPosePreviewControllerParamsDto} setPosePreviewControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerSetPosePreviewV1: async (id: string, setPosePreviewControllerParamsDto: SetPosePreviewControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posesControllerSetPosePreviewV1', 'id', id)
            // verify required parameter 'setPosePreviewControllerParamsDto' is not null or undefined
            assertParamExists('posesControllerSetPosePreviewV1', 'setPosePreviewControllerParamsDto', setPosePreviewControllerParamsDto)
            const localVarPath = `/v1/poses/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPosePreviewControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posesControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('posesControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/poses/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PosesApi - functional programming interface
 * @export
 */
export const PosesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PosesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerGetPoseV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerGetPoseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPosesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerListPosesV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerListPosesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SetPosePreviewControllerParamsDto} setPosePreviewControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerSetPosePreviewV1(id: string, setPosePreviewControllerParamsDto: SetPosePreviewControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerSetPosePreviewV1(id, setPosePreviewControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerSetPosePreviewV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PosesApi - factory interface
 * @export
 */
export const PosesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PosesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PoseEntity> {
            return localVarFp.posesControllerGetPoseV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPosesDto> {
            return localVarFp.posesControllerListPosesV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SetPosePreviewControllerParamsDto} setPosePreviewControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerSetPosePreviewV1(id: string, setPosePreviewControllerParamsDto: SetPosePreviewControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.posesControllerSetPosePreviewV1(id, setPosePreviewControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.posesControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PosesApi - object-oriented interface
 * @export
 * @class PosesApi
 * @extends {BaseAPI}
 */
export class PosesApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerGetPoseV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerListPosesV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SetPosePreviewControllerParamsDto} setPosePreviewControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerSetPosePreviewV1(id: string, setPosePreviewControllerParamsDto: SetPosePreviewControllerParamsDto, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerSetPosePreviewV1(id, setPosePreviewControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PosesControllerListPosesV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC'
} as const;
export type PosesControllerListPosesV1OrderByEnum = typeof PosesControllerListPosesV1OrderByEnum[keyof typeof PosesControllerListPosesV1OrderByEnum];


/**
 * StacksApi - axios parameter creator
 * @export
 */
export const StacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddItemsV1: async (id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerAddItemsV1', 'id', id)
            // verify required parameter 'addItemsToStackControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerAddItemsV1', 'addItemsToStackControllerParamsDto', addItemsToStackControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/items/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToStackControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1: async (createStackParamsDto: CreateStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStackParamsDto' is not null or undefined
            assertParamExists('stacksControllerCreateStackV1', 'createStackParamsDto', createStackParamsDto)
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerGetStackV1', 'id', id)
            const localVarPath = `/v1/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1: async (orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveItemsV1: async (id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerRemoveItemsV1', 'id', id)
            // verify required parameter 'removeItemsFromCollectionControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerRemoveItemsV1', 'removeItemsFromCollectionControllerParamsDto', removeItemsFromCollectionControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/items/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/stacks/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StacksApi - functional programming interface
 * @export
 */
export const StacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerAddItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerCreateStackV1(createStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerCreateStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerGetStackV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerGetStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStacksDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerListStacksV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerListStacksV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerRemoveItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StacksApi - factory interface
 * @export
 */
export const StacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StacksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerGetStackV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListStacksDto> {
            return localVarFp.stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
export class StacksApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStackParamsDto} createStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerGetStackV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StacksControllerListStacksV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type StacksControllerListStacksV1OrderByEnum = typeof StacksControllerListStacksV1OrderByEnum[keyof typeof StacksControllerListStacksV1OrderByEnum];


/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1: async (createStorageRecordParamsDto: CreateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerCreateRecordV1', 'createStorageRecordParamsDto', createStorageRecordParamsDto)
            const localVarPath = `/v1/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1: async (deleteStorageParamsDto: DeleteStorageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteStorageParamsDto' is not null or undefined
            assertParamExists('storageControllerDeleteRecordV1', 'deleteStorageParamsDto', deleteStorageParamsDto)
            const localVarPath = `/v1/storage/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStorageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1: async (getStorageRecordParamsDto: GetStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerGetRecordsV1', 'getStorageRecordParamsDto', getStorageRecordParamsDto)
            const localVarPath = `/v1/storage/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1: async (updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerUpdateRecordV1', 'updateStorageRecordParamsDto', updateStorageRecordParamsDto)
            const localVarPath = `/v1/storage/write`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerCreateRecordV1(createStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerCreateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerDeleteRecordV1(deleteStorageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerDeleteRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageRecordsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerGetRecordsV1(getStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerGetRecordsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerUpdateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageRecordsResultDto>> {
            return localVarFp.storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * 
     * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVideoParamsDto} createVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerFinalizeUploadV1: async (createVideoParamsDto: CreateVideoParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVideoParamsDto' is not null or undefined
            assertParamExists('videosControllerFinalizeUploadV1', 'createVideoParamsDto', createVideoParamsDto)
            const localVarPath = `/v1/videos/upload/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVideoParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerGetVideoByIdV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videosControllerGetVideoByIdV1', 'id', id)
            const localVarPath = `/v1/videos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerGetVideosV1: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('videosControllerGetVideosV1', 'ids', ids)
            const localVarPath = `/v1/videos/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerStartUploadV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/videos/upload/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateVideoParamsDto} createVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosControllerFinalizeUploadV1(createVideoParamsDto: CreateVideoParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosControllerFinalizeUploadV1(createVideoParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.videosControllerFinalizeUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosControllerGetVideoByIdV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosControllerGetVideoByIdV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.videosControllerGetVideoByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosControllerGetVideosV1(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VideoEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosControllerGetVideosV1(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.videosControllerGetVideosV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosControllerStartUploadV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializeImageUploadResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosControllerStartUploadV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.videosControllerStartUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideosApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateVideoParamsDto} createVideoParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerFinalizeUploadV1(createVideoParamsDto: CreateVideoParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<VideoEntity> {
            return localVarFp.videosControllerFinalizeUploadV1(createVideoParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerGetVideoByIdV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VideoEntity> {
            return localVarFp.videosControllerGetVideoByIdV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerGetVideosV1(ids: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<VideoEntity>> {
            return localVarFp.videosControllerGetVideosV1(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosControllerStartUploadV1(options?: RawAxiosRequestConfig): AxiosPromise<InitializeImageUploadResultDto> {
            return localVarFp.videosControllerStartUploadV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * 
     * @param {CreateVideoParamsDto} createVideoParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosControllerFinalizeUploadV1(createVideoParamsDto: CreateVideoParamsDto, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosControllerFinalizeUploadV1(createVideoParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosControllerGetVideoByIdV1(id: string, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosControllerGetVideoByIdV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosControllerGetVideosV1(ids: Array<string>, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosControllerGetVideosV1(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosControllerStartUploadV1(options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosControllerStartUploadV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerGetSettingsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerGetSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerRegisterWebsocketV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerRegisterWebsocketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerGetSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerRegisterWebsocketV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerGetSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerRegisterWebsocketV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkflowParamsDto} createWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerCreateWorkflowV1: async (createWorkflowParamsDto: CreateWorkflowParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowParamsDto' is not null or undefined
            assertParamExists('workflowsControllerCreateWorkflowV1', 'createWorkflowParamsDto', createWorkflowParamsDto)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerDeleteWorkflowV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowsControllerDeleteWorkflowV1', 'id', id)
            const localVarPath = `/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerGetWorkflowV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowsControllerGetWorkflowV1', 'id', id)
            const localVarPath = `/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WorkflowsControllerListWorkflowsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerListWorkflowsV1: async (orderBy?: WorkflowsControllerListWorkflowsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workflowId 
         * @param {RunWorkflowParamsDto} runWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerRunWorkflowV1: async (workflowId: string, runWorkflowParamsDto: RunWorkflowParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('workflowsControllerRunWorkflowV1', 'workflowId', workflowId)
            // verify required parameter 'runWorkflowParamsDto' is not null or undefined
            assertParamExists('workflowsControllerRunWorkflowV1', 'runWorkflowParamsDto', runWorkflowParamsDto)
            const localVarPath = `/v1/workflows/run/{workflowId}`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runWorkflowParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkflowParamsDto} updateWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerUpdateWorkflowV1: async (id: string, updateWorkflowParamsDto: UpdateWorkflowParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowsControllerUpdateWorkflowV1', 'id', id)
            // verify required parameter 'updateWorkflowParamsDto' is not null or undefined
            assertParamExists('workflowsControllerUpdateWorkflowV1', 'updateWorkflowParamsDto', updateWorkflowParamsDto)
            const localVarPath = `/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkflowParamsDto} createWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerCreateWorkflowV1(createWorkflowParamsDto: CreateWorkflowParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerCreateWorkflowV1(createWorkflowParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerCreateWorkflowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerDeleteWorkflowV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerDeleteWorkflowV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerDeleteWorkflowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerGetWorkflowV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerGetWorkflowV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerGetWorkflowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WorkflowsControllerListWorkflowsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerListWorkflowsV1(orderBy?: WorkflowsControllerListWorkflowsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkflowsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerListWorkflowsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerListWorkflowsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workflowId 
         * @param {RunWorkflowParamsDto} runWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerRunWorkflowV1(workflowId: string, runWorkflowParamsDto: RunWorkflowParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunWorkflowResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerRunWorkflowV1(workflowId, runWorkflowParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerRunWorkflowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkflowParamsDto} updateWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsControllerUpdateWorkflowV1(id: string, updateWorkflowParamsDto: UpdateWorkflowParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsControllerUpdateWorkflowV1(id, updateWorkflowParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.workflowsControllerUpdateWorkflowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkflowParamsDto} createWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerCreateWorkflowV1(createWorkflowParamsDto: CreateWorkflowParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDto> {
            return localVarFp.workflowsControllerCreateWorkflowV1(createWorkflowParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerDeleteWorkflowV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workflowsControllerDeleteWorkflowV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerGetWorkflowV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDto> {
            return localVarFp.workflowsControllerGetWorkflowV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkflowsControllerListWorkflowsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerListWorkflowsV1(orderBy?: WorkflowsControllerListWorkflowsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListWorkflowsDto> {
            return localVarFp.workflowsControllerListWorkflowsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workflowId 
         * @param {RunWorkflowParamsDto} runWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerRunWorkflowV1(workflowId: string, runWorkflowParamsDto: RunWorkflowParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<RunWorkflowResponseDto> {
            return localVarFp.workflowsControllerRunWorkflowV1(workflowId, runWorkflowParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkflowParamsDto} updateWorkflowParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsControllerUpdateWorkflowV1(id: string, updateWorkflowParamsDto: UpdateWorkflowParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDto> {
            return localVarFp.workflowsControllerUpdateWorkflowV1(id, updateWorkflowParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkflowParamsDto} createWorkflowParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerCreateWorkflowV1(createWorkflowParamsDto: CreateWorkflowParamsDto, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerCreateWorkflowV1(createWorkflowParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerDeleteWorkflowV1(id: string, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerDeleteWorkflowV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerGetWorkflowV1(id: string, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerGetWorkflowV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkflowsControllerListWorkflowsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerListWorkflowsV1(orderBy?: WorkflowsControllerListWorkflowsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerListWorkflowsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workflowId 
     * @param {RunWorkflowParamsDto} runWorkflowParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerRunWorkflowV1(workflowId: string, runWorkflowParamsDto: RunWorkflowParamsDto, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerRunWorkflowV1(workflowId, runWorkflowParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWorkflowParamsDto} updateWorkflowParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsControllerUpdateWorkflowV1(id: string, updateWorkflowParamsDto: UpdateWorkflowParamsDto, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsControllerUpdateWorkflowV1(id, updateWorkflowParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const WorkflowsControllerListWorkflowsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type WorkflowsControllerListWorkflowsV1OrderByEnum = typeof WorkflowsControllerListWorkflowsV1OrderByEnum[keyof typeof WorkflowsControllerListWorkflowsV1OrderByEnum];


