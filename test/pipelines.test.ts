import { describe, expect, it } from '@jest/globals';
import fs from 'fs';
import { SDK } from '../src';
import { PipelineDtoStatusEnum } from '../src/autogenerated';
import { recreateSdk } from './utils';

describe('Pipelines', () => {
    let sdk: SDK;

    beforeAll(() => {
        sdk = recreateSdk();
    });

    afterAll(async () => {
        await sdk.close();
    });

    it('should create collection pipeline', async () => {
        const pipelineTemplate = sdk.pipelines.constructTemplate((pipeline) => {
            const stack = pipeline.defer.stacks.create({});

            const collection = pipeline.defer.collections.create({});
            const gotCollection = pipeline.defer.collections.get({ collectionId: collection.result.id });

            pipeline.defer.collections.items.add({
                collectionId: gotCollection.result.id,
                itemIds: [stack.result.id],
            });
            pipeline.defer.collections.items.list({
                collectionId: gotCollection.result.id,
            });
            pipeline.defer.collections.items.remove({
                collectionId: gotCollection.result.id,
                itemIds: [stack.result.id],
            });
            // pipeline.defer.collections.updateMetadata({
            //     id: gotCollection.result.id,
            //     update: { overwrite: { name: 'test' } },
            // });
            return pipeline;
        });

        const pipeline = await sdk.pipelines.create({ template: pipelineTemplate });
        expect(pipeline).toBeDefined();

        const finishedPipeline = await sdk.pipelines.wait({ id: pipeline.id });
        expect(finishedPipeline).toBeDefined();
    });

    it('should run pipeline with operation', async () => {
        const file = new Blob([fs.readFileSync('./test/image.jpeg')], { type: 'image/jpeg' });
        const image = await sdk.images.createFromFile({ file });

        const template = sdk.pipelines.constructTemplate((pipeline) => {
            const negateImage = pipeline.defer.operations.wait({
                id: pipeline.defer.operations.run.negateImage.v1({
                    input: {
                        imageId: image.id,
                    },
                }).result.id,
            });

            const negate2 = pipeline.defer.operations.wait({
                id: pipeline.defer.operations.run.negateImage.v1({
                    input: {
                        imageId: negateImage.result.id,
                    },
                }).result.id,
            });

            return pipeline;
        });

        const pipeline = await sdk.pipelines.create({ template });
        expect(pipeline).toBeDefined();

        const finishedPipeline = await sdk.pipelines.wait({ id: pipeline.id });
        expect(finishedPipeline).toBeDefined();

        expect(finishedPipeline.status).toBe(PipelineDtoStatusEnum.Completed);
    });

    it('should return error on semantically incorrect wait', async () => {
        const file = new Blob([fs.readFileSync('./test/image.jpeg')], { type: 'image/jpeg' });
        const image = await sdk.images.createFromFile({ file });

        const template = sdk.pipelines.constructTemplate((pipeline) => {
            const negateImage = pipeline.defer.operations.wait(
                // @ts-expect-error Error is expected as this is semantically incorrect usage
                pipeline.defer.operations.run.negateImage.v1({
                    input: {
                        imageId: image.id,
                    },
                }),
            );
            return pipeline;
        });

        const pipeline = await sdk.pipelines.create({ template });
        expect(pipeline).toBeDefined();

        const finishedPipeline = await sdk.pipelines.wait({ id: pipeline.id });
        expect(finishedPipeline).toBeDefined();

        expect(finishedPipeline.status).toBe(PipelineDtoStatusEnum.Failed);
    });
});
