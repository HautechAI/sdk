#!/bin/node

const outputFilePath = process.argv[2];

const fs = require('fs');
const path = require('path');

// Read the call.ts file to extract method information
const callFilePath = path.join(__dirname, '../src/autogenerated/call/call.ts');
const callFileContent = fs.readFileSync(callFilePath, 'utf-8');

// Extract method definitions with their URLs
function extractMethodInfo() {
    const methodInfos = [];

    // Regex to match method definitions with their URLs
    const methodRegex = /const\s+(callController\w+)\s*=\s*\([^)]*\)\s*=>\s*{[^}]*url:\s*`([^`]+)`/g;

    let match;
    while ((match = methodRegex.exec(callFileContent)) !== null) {
        const methodName = match[1];
        const url = match[2];

        // Only include methods that start with /v1/call/
        if (url.startsWith('/v1/call/')) {
            methodInfos.push({
                methodName,
                url,
            });
        }
    }

    return methodInfos;
}

// Convert dot-separated path to nested object structure
function createNestedObject(path, methodName, result = {}) {
    const parts = path.split('.');
    let current = result;

    for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!current[part]) {
            current[part] = {};
        }
        current = current[part];
    }

    // Set the final method
    const lastPart = parts[parts.length - 1];
    current[lastPart] = `api.${methodName}`;

    return result;
}

// Generate the nested object structure
function generatePipelineMethods() {
    const methodInfos = extractMethodInfo();
    const result = {};

    console.log(`Found ${methodInfos.length} call controller methods:`);

    methodInfos.forEach(({ methodName, url }) => {
        // Extract the operation part after /v1/call/
        const operationPath = url.replace('/v1/call/', '');
        console.log(`${methodName} -> ${operationPath}`);

        createNestedObject(operationPath, methodName, result);
    });

    return result;
}

// Generate TypeScript code for the object
function generateTypeScriptCode(obj, indent = 0) {
    const spaces = '  '.repeat(indent);
    let code = '{\n';

    for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string') {
            // This is a method reference
            code += `${spaces}  ${key}: ${value},\n`;
        } else {
            // This is a nested object
            code += `${spaces}  ${key}: ${generateTypeScriptCode(value, indent + 1)},\n`;
        }
    }

    code += `${spaces}}`;
    return code;
}

// Main execution
function main() {
    const callObject = generatePipelineMethods();

    const tsCode = `import { getCall } from '../autogenerated/call/call';

export const usePipelineDefinitions = () => {
    const api = getCall();
    
    return ${generateTypeScriptCode(callObject)};
};
`;

    fs.writeFileSync(outputFilePath, tsCode);
}

if (require.main === module) {
    main();
}
